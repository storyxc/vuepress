---
title: Vue
date: 2023-04-15 12:48:26
permalink: /pages/e4e297/
categories:
  - 前端
  - 框架
tags:
  - Vue
---

# Vue

> Vue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式框架**。

## 特性

- 数据驱动视图：在数据变化时页面会重新渲染
- 双向数据绑定：DOM元素中的数据和Vue实例中的data保持一致，无论谁被改变，另一方都会更新为相同的数据

### MVVM

MVVM是Vue实现数据驱动视图和双向数据绑定的原理。MVVM指的是Model、View和ViewModel。

- Model：当前页面渲染时依赖的数据源
- View：当前页面渲染的DOM结构
- ViewModel：Vue的实例，MVVM的核心

ViewModel把Model和View连接在一起，同时监听DOM变化和数据源的变化。

## 起步

```html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<div id="app">
    {{ msg }}
</div>
<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
<script>
    const vm = new Vue({
        el: '#app',
        data: {
            msg: 'hello world'
        }
    })
</script>
</body>
</html>
```

## 指令和过滤器

### 内容渲染

- v-test
  - `<p v-test=username></p>`：把username值渲染到p标签中
  - `<p v-test=gender>性别</p>`:把gender值渲染到p标签中，原有的值会被覆盖
- {{ }}
  - 插值表达式(Mustache),专门用来解决v-text会覆盖默认文本内容的问题，不能用在属性上
  - `<p>性别 {{ gender }}</p>`
  - 支持javascript表达式
- v-html
  - 把包含HTML标签的字符串渲染为页面的HTML元素

### 属性绑定

- v-bind：单向绑定
  - `v-bind:属性名`
  - 简写为`:属性名`
  - 支持javascript表达式

### 事件绑定

#### v-on

- `v-on:事件名="函数(param)"`：v-on:click="add"

- 简写为：`@`,例如`@click="add"`

- 函数定义在vue实例的methods中

- ```js
  methods: {
    add: function(param) {
    	console.log(1)
  	}
  }
  ---
  ES6写法： 
  methods: {
    add(param) {
    	console.log(1)
  	}
  }  
  ```

- 不传参数默认参数列表有事件对象e,如果传参可以用`$event`传递事件对象

- 事件修饰符

  - `@click.prevent=show()`：绑定事件并阻止默认行为
  - stop：阻止事件冒泡
  - capture：以捕获模式触发当前事件处理函数
  - once：绑定事件只触发一次
  - self：只有在even.target时当前元素自身时触发事件处理函数

- 按键修饰符

  - 判断详细的案件
    - @keyup.enter=submit
    - esc

### 双向绑定

- v-model：不操作DOM情况下，快速获取表单数据
- 修饰符
  - .nubmer：自动将输入转为数值
  - .trim：自动过滤输入的首尾空白字符
  - .lazy：在change时更新，input时不更新

### 条件渲染

控制DOM的显示与隐藏

- v-if
  - 通过添加、移除元素实现
  - 如果刚进入页面不需要被展示，而且后期可能也不需要展示此时v-if性能更好
  - 配套指令：v-else、v-else-if
- v-show
  - display控制元素显示、隐藏
  - 如果频繁切换显示状态用v-show更好

### 列表渲染

基于一个数组来循环渲染一个列表结构。v-for指令需要用item in items形式的特殊语法

```js
<li v-for="item in items">姓名是： {{ item.name }}</li>
```
```js
<li v-for="(item,index) in items">姓名是： {{ item.name }}</li>
```

- items：待循环数组
- item：被循环的每一项
- index：索引号，从0开始

建议用到v-for指令，要绑定一个`:key`属性，而且尽量把id作为key

- key的值要是字符串/数字类型
- index作为key没有任何意义，因为index没有唯一性（和数据没有绑定关系）
- 指定key可以提升性能、防止列表状态紊乱

### 过滤器（vue3已移除）

常用于文本格式化，过滤器可以用在两个地方：插值表达式和v-bind属性绑定，过滤器本质是函数，被定义在vue实例的filters节点下

- `<p> {{ message | capitalize }}</p>`：调用captitalize过滤器，对message进行格式化
- `<div v-bind:id="rawId | formatId"></div`：调用formatId过滤器，对rawId进行格式化

```js
filters: {
  capitalize(val) {
    return val.charAt(0).toUppercase() + var.slice(1)
  }
}
```

#### 私有过滤器和全局过滤器

- 私有过滤器：定义在vue实例的filters节点下
- 全局过滤器：使用Vue.filter(filter, (str) => {return xxx})定义

#### 连续调用&传参

`{{ msg | filterA | filterB(arg1, arg2)}}`

## 侦听器

watch侦听器语序开发者监视数据的变化，从而针对数据的变化做特定的操作。

### 侦听器格式

watch定义在vue实例的watch节点下

- 方法格式的侦听器
  
  - ```js
    watch: {
      username(newVal, oldVal) {
        console.log(newVal, oldVal)
      }
    }
    ```
  
  - 缺点
  
    - 无法在刚进入页面时自动触发
    - 如果侦听的是一个对象，对象属性发生变化不会触发侦听器
  
- 对象格式的侦听器
  - ```js
    watch: {
      username: {
        handler(newVal, oldVal) {
        console.log(newVal, oldVal)
      },
      immediate: true,
      deep: true,
      'info.age'(newVal) {
        console.log(newVal)
      }
    }
    ```

  - 可以通过**immediate**选项让侦听器立即触发

  - 可以通过`deep`选项开启深度监听，可以监听到对象的任何一个属性变化

  - 如果要侦听的是对象的子属性变化，则必须包裹一层单引号

## 计算属性

通过运算得到的属性值，可以被模版结构或methods方法使用。

计算属性放在vue实例的`computed`节点中

```js
var vm = new Vue({
  el: '#app',
  data: {
    r: 0, g: 0, b: 0
  },
  computed: {
    //计算属性rgb
    rgb() { return `rgb(${this.r}, ${this.g}, ${this.b})`}
    //计算属性 allChecked
    allChecked: {
    	get() {
      	return this.goodsList.every(item => item.goods_state)
    	},
    	set(newVal) {
      	this.goodsList.forEach(item => item.goods_state = newVal)
    	}
		}
  },
  methods: {
    show() { console.log(this.rgb) }
  }
})
```

```js
computed: {
  allChecked: {
    get() {
      return this.goodsList.every(item => item.goods_state)
    },
    set(newVal) {
      this.goodsList.forEach(item => item.goods_state = newVal)
    }
  }
}
```



## axios

> axios一个专注于网络请求的库

基本语法：

```js
axios({
  method: '请求类型',
  // URL中的query参数
  params: {
    
  },
  // body参数
  data: {
  
}
  url: '请求的URL地址',
}).then((result) => {
  //.then用来指定成功的回调，result是请求成功后的结果
})
```

结合async和await使用axios

```js
document.querySelector('#btn').addEventListener('click', async function(){
  // 如果调用方法返回值是Promise实例，则可以在前面添加await，await只能用在被async“修饰”的方法中
  // 解构赋值的时候使用：进行重命名
  const { data: res } = await axios({
    method: 'POST',
    url: 'xxx',
    data: {
      name: '111'
    }
  })
  console.log(res.data)
})
```

- axios.get()
- axios.post()
- axios.delete()
- axios.put()



## vue-cli

> 单页面应用程序（Single Page Application）简称SPA，指的是一个Web网站中只有唯一的一个HTML页面，所有的功能与交互都在这唯一的一个页面内完成。

vue-cli是Vue.js开发的标准工具。简化了基于webpack创建工程化的Vue项目的过程。

### 安装

`npm install -g @vue/cli`

### 创建项目

`vue create projectName`

## vue组件

### 组件组成

组件后缀名是`.vue`，vue组件包括三个组成部分

#### template

```vue
<template>
	<div>
    <!--template中只能有一个根元素-->
  </div>
</template>
```

#### script

```vue
<script>
export default {
  name: 'xxx',
  // data必须是一个函数
  data() {
    return {
      xx: xx
    }
  },
  methods: {
    fun() {
      // 组件中的this代表当前组件的实例对象
      console.log(this)
      this.xx = yy
    }
  },
  watch: {},
  computed: {}
  ...
}
</script>
```

#### style

```vue
<style lang="less">/* 默认lang="css" */

</style>
```

### 组件之间的父子关系

组件被封装好后，彼此之间是相互独立的，不存在父子关系。

在**使用组件**时，根据彼此的嵌套关系，形成了父子关系，兄弟关系。

### 组件使用步骤

#### 注册私有子组件

1. import语法导入需要的组件

```js
import A from '@/components/A.vue
```

2. 使用components节点注册组件

```js
export default {
	components: {
		A
  }
}
```

3. 以标签形式使用注册的组件

```vue
<div class="box">
  <A></A>
</div>
```

#### 注册全局组件

```js
// main.js

import Test from '@/components/Test.vue'

Vue.component('MyTest', Test)
```

### 组件的props

props是组件的**自定义属性**，在封装通用组件的时候，合理的使用props可以极大提高组件的复用性。

- props中的数据，可以直接在模板结构中使用
- props是只读的

```vue
<script>
export default {
  props: {
    initCount: {
      default: 0,//默认值
      type: Number, //规定属性的值类型，如果传递的值不符合，则会报错
      required: true //必填项
    }
  },
  data() {
    return {
      count: this.initCount
    }
  }
}
</script>
```

### 组件之间样式冲突

默认情况下，写在组件中的样式会全局生效，原因是：

1. 单页面应用程序中所有的DOM结构都是基于唯一的index.hmtl页面进行呈现的
2. 每个组件中的样式都会影响整个index.html的DOM元素

#### 解决方案

- 使用自定义属性:DOM元素增加自定义属性`data-v-xxx`，使用属性选择器设置样式`div[data-v-xxx]`

- **style标签增加`scoped`属性**,会自动为每个标签生成`data-v`属性

### deep样式穿透

`/deep/ 选择器`

当使用第三方组件库，如果有修改第三方组件库的默认样式需求，需要用到deep

### 组件的生命周期

生命周期是指一个组件从创建->运行->销毁的整个阶段。

#### 分类

- 组件创建阶段
  - beforeCreate：组件的props/data/methods尚未被创建，都处于不可用状态
  - created：组件的props/data/methods被创建，都处于可用状态，但是组件的模板结构尚未生成
  - beforeMount：将要把内存中编译好的HTML结果渲染到浏览器中，此时浏览器中还没有当前组件的DOM结构
  - mounted：已经把内存中编译好的HTML结果渲染到浏览器中，此时浏览器已经包含当前组件DOM结构
- 组件运行阶段
  - beforeUpdate：将要根据变化过后、最新的数据重新渲染组件的模版结构
  - updated：已经根据最新的数据，完成了组件DOM结构的重新渲染
- 组件销毁阶段
  - beforeDestroy：将要销毁此组件但还未销毁，组件还处于正常工作状态
  - destroyed：组件已被销毁，此组件在浏览器中对应的DOM结构已被完全移除

#### 组件数据共享

#### 父组件向子组件共享数据需要使用自定义属性

#### 子向父传值需要使用自定义事件

```js
//子组件
methods: {
  add() {
    this.count += 1
	  this.$emit('numchange', this.count)
  }
}
```

```js
//父组件
<Son @numchange="getNewCount"></Son>

---

methods: {
	getNewCount(val) {
		this.countFromSon = val
	}
}
```

#### 兄弟组件之间数据共享需要使用EventBus

```js
//A组件
import bus from './eventBus.js'

methods: {
	sendMsg() {
		bus.$emit('share', this.msg)
	}
}

//eventBus.js
import Vue from 'vue'

export default new Vue()

//兄弟组件B
import bus from './eventBus.js'

created() {
	bus.$on('share', val => {
		this.msgFromSibling = val
	})
}
```

### ref引用

ref用来辅助开发者在不依赖jQuery的情况下，获取DOM元素或组件的引用

每个vue组件的实例上，都包含一个`$refs`对象，里面存储着对应的DOM元素或组件的引用，默认情况下组件的`$refs`指向一个空对象

#### 使用ref引用页面上的DOM元素

```vue
<div ref="myDiv"></div>

// methods中访问
this.$refs.myDiv
```

#### 使用ref引用组件

```vue
<Son ref="compSon"></Son>

// methods中访问
this.$refs.compSon.方法
this.$refs.compSon.属性
```

#### $nextTick(callback)

组件的$nextTick(callback)方法，会把callback函数会推迟到下一个DOM更新之后执行。
