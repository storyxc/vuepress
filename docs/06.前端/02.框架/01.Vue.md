---
title: Vue
date: 2023-04-15 12:48:26
permalink: /pages/e4e297/
categories:
  - 前端
  - 框架
tags:
  - Vue
---

# Vue

> Vue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式框架**。

## 特性

- 数据驱动视图：在数据变化时页面会重新渲染
- 双向数据绑定：DOM元素中的数据和Vue实例中的data保持一致，无论谁被改变，另一方都会更新为相同的数据

### MVVM

MVVM是Vue实现数据驱动视图和双向数据绑定的原理。MVVM指的是Model、View和ViewModel。

- Model：当前页面渲染时依赖的数据源
- View：当前页面渲染的DOM结构
- ViewModel：Vue的实例，MVVM的核心

ViewModel把Model和View连接在一起，同时监听DOM变化和数据源的变化。

## 起步

```html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<div id="app">
    {{ msg }}
</div>
<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
<script>
    const vm = new Vue({
        el: '#app',
        data: {
            msg: 'hello world'
        }
    })
</script>
</body>
</html>
```

## 指令和过滤器

### 内容渲染

- v-test
  - `<p v-test=username></p>`：把username值渲染到p标签中
  - `<p v-test=gender>性别</p>`:把gender值渲染到p标签中，原有的值会被覆盖
- {{ }}
  - 插值表达式(Mustache),专门用来解决v-text会覆盖默认文本内容的问题，不能用在属性上
  - `<p>性别 {{ gender }}</p>`
  - 支持javascript表达式
- v-html
  - 把包含HTML标签的字符串渲染为页面的HTML元素

### 属性绑定

- v-bind：单向绑定
  - `v-bind:属性名`
  - 简写为`:属性名`
  - 支持javascript表达式

### 事件绑定

#### v-on

- `v-on:事件名="函数(param)"`：v-on:click="add"

- 简写为：`@`,例如`@click="add"`

- 函数定义在vue实例的methods中

- ```js
  methods: {
    add: function(param) {
    	console.log(1)
  	}
  }
  ---
  ES6写法： 
  methods: {
    add(param) {
    	console.log(1)
  	}
  }  
  ```

- 不传参数默认参数列表有事件对象e,如果传参可以用`$event`传递事件对象

- 事件修饰符

  - `@click.prevent=show()`：绑定事件并阻止默认行为
  - stop：阻止事件冒泡
  - capture：以捕获模式触发当前事件处理函数
  - once：绑定事件只触发一次
  - self：只有在even.target时当前元素自身时触发事件处理函数

- 按键修饰符

  - 判断详细的案件
    - @keyup.enter=submit
    - esc

### 双向绑定

- v-model：不操作DOM情况下，快速获取表单数据
- 修饰符
  - .nubmer：自动将输入转为数值
  - .trim：自动过滤输入的首尾空白字符
  - .lazy：在change时更新，input时不更新

### 条件渲染

控制DOM的显示与隐藏

- v-if
  - 通过添加、移除元素实现
  - 如果刚进入页面不需要被展示，而且后期可能也不需要展示此时v-if性能更好
  - 配套指令：v-else、v-else-if
- v-show
  - display控制元素显示、隐藏
  - 如果频繁切换显示状态用v-show更好

### 列表渲染

基于一个数组来循环渲染一个列表结构。v-for指令需要用item in items形式的特殊语法

- `<li v-for="item in items">姓名是： {{ item.name }}</li>`
- `<li v-for="(item,index) in items">姓名是： {{ item.name }}</li>`

- items：待循环数组
- item：被循环的每一项
- index：索引号，从0开始

建议用到v-for指令，要绑定一个`:key`属性，而且尽量把id作为key

- key的值要是字符串/数字类型
- index作为key没有任何意义，因为index没有唯一性（和数据没有绑定关系）
- 指定key可以提升性能、防止列表状态紊乱

### 过滤器（vue3已移除）

常用于文本格式化，过滤器可以用在两个地方：插值表达式和v-bind属性绑定，过滤器本质是函数，被定义在vue实例的filters节点下

- `<p> {{ message | capitalize }}</p>`：调用captitalize过滤器，对message进行格式化
- `<div v-bind:id="rawId | formatId"></div`：调用formatId过滤器，对rawId进行格式化

```js
filters: {
  capitalize(val) {
    return val.charAt(0).toUppercase() + var.slice(1)
  }
}
```

#### 私有过滤器和全局过滤器

- 私有过滤器：定义在vue实例的filters节点下
- 全局过滤器：使用Vue.filter(filter, (str) => {return xxx})定义

#### 连续调用&传参

`{{ msg | filterA | filterB(arg1, arg2)}}`

## 侦听器

watch侦听器语序开发者监视数据的变化，从而针对数据的变化做特定的操作。

### 侦听器格式

watch定义在vue实例的watch节点下

- 方法格式的侦听器
  
  - ```js
    watch: {
      username(newVal, oldVal) {
        console.log(newVal, oldVal)
      }
    }
    ```
  
  - 缺点
  
    - 无法在刚进入页面时自动触发
    - 如果侦听的是一个对象，对象属性发生变化不会触发侦听器
  
- 对象格式的侦听器
  - ```js
    watch: {
      username: {
        handler(newVal, oldVal) {
        console.log(newVal, oldVal)
      },
      immediate: true,
      deep: true,
      'info.age'(newVal) {
        console.log(newVal)
      }
    }
    ```

  - 可以通过**immediate**选项让侦听器立即触发

  - 可以通过`deep`选项开启深度监听，可以监听到对象的任何一个属性变化

  - 如果要侦听的是对象的子属性变化，则必须包裹一层单引号

## 计算属性

通过运算得到的属性值，可以被模版结构或methods方法使用。

计算属性放在vue实例的`computed`节点中，计算属性在定义的时候要定义成**"方法格式"**

```js
var vm = new Vue({
  el: '#app',
  data: {
    r: 0, g: 0, b: 0
  },
  computed: {
    //rgb作为一个计算属性，被定义成了方法格式
    rgb() { return `rgb(${this.r}, ${this.g}, ${this.b})`}
  },
  methods: {
    show() { console.log(this.rgb) }
  }
})
```

## axios

> axios一个专注于网络请求的库

基本语法：

```js
axios({
  method: '请求类型',
  // URL中的query参数
  params: {
    
  },
  // body参数
  data: {
  
}
  url: '请求的URL地址',
}).then((result) => {
  //.then用来指定成功的回调，result是请求成功后的结果
})
```

结合async和await使用axios

```js
document.querySelector('#btn').addEventListener('click', async function(){
  // 如果调用方法返回值是Promise实例，则可以在前面添加await，await只能用在被async“修饰”的方法中
  // 解构赋值的时候使用：进行重命名
  const { data: res } = await axios({
    method: 'POST',
    url: 'xxx',
    data: {
      name: '111'
    }
  })
  console.log(res.data)
})
```

- axios.get()
- axios.post()
- axios.delete()
- axios.put()



