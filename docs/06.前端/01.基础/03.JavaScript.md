---
title: JavaScript
date: 2023-04-06 20:03:56
permalink: /pages/214c71/
categories:
  - 前端
  - 基础
tags:
  - js
  - JavaScript
---
# JavaScript

## 组成

- ECMAScript：规定了js基础语法，比如变量、分支语句、循环语句、对象等
- Web APIs
  - DOM：操作文档，比如对页面元素移动、添加删除等操作
  - BOM：操作浏览器，比如页面弹窗、检测窗口宽度、存储数据到浏览器等

## 基本语法

### 输入

`prompt()`

### 输出

`console.log()`

`document.write()`

`alert()`

> alert和prompt会跳过页面渲染先被执行

### 变量

#### 声明

- `let`

> 比较旧的JavaScript中使用var声明变量
>
> var的一些问题：
>
> - 可以先使用，再声明
> - var声明过的变量可以重复声明
> - 变量提升、全局变量、没有块级作用域

#### 命名

- 只能下划线、字母、数字、$，且不能数字开头
- 字母区分大小写

##### 规范

- 小驼峰

### 数组

- `let arr = [1, 2, 3]` / `let arr = new Array(1, 2, 3)`
- 数组有序
- 取值：数组[下标]
- 长度：数组.length
- 修改：arr[下标] = 新值
- 增加
  - arr.push() 将一个或多个元素新增到末尾，返回新的数组长度
  - arr.unshift()将一个或多个元素新增到开头，返回新的数组长度

- 删除
  - arr.pop() 删除最后一个元素，并返回该元素的值
  - arr.shift()删除第一个元素，并返回该元素的值
  - arr.splice(操作的下标，删除的个数)，删除指定元素并返回


### 常量

- 声明：`const`
- 声明常量必须赋值

### 数据类型

#### 基本数据类型

- number

- string

  - 模板字符串: 使用反引号包裹数据，使用${}替换数据

    ```js
    let age = 20
    console.log(`我今年${age}岁`)
    ```

- boolean

- undefined

  - 没有赋值
  - undefined +1 -> NaN

- null

  - 内容为空
  - null + 1 -> 1

##### NaN

NaN代表一个计算错误，是一个不正确或未定义的数学操作得到的结果，任何对NaN的操作都会返回NaN

#### typeof

- 运算符写法：typeof 变量
- 函数写法：typeof(变量)

#### 数据类型转换

##### 隐式转换

- `+`号两边只要有字符串，都会转字符串
- 除了`+`，其他算数运算符会把数据转换为数字类型
- `+`作为正号可以转换数字

##### 显式转换

- Number(变量)

#### 引用数据类型

- object

  ```js
  let obj = {
    uname: 'abc',
    age: 18,
    gender: '女',
    speak: function(x) {
      console.log('hello' + x)
    }
  }
  ```

  - 属性名可以用引号，一般省略，除非遇到特殊符号（空格、中横线等）

- 查看: 

  - 对象.属性
  - 对象['属性']

- 修改: 对象.属性 = 新值

- 新增: 对象.新属性 = 值

- 删除: delete 对象.属性

- 对象方法: 对象.方法名()

- 遍历对象

  - ```js
    for (let k in obj) {
      console.log(obj[k]) //k带引号
    }
    ```


> for in遍历数组 是数组下标，但是是字符串
>

### 运算符

#### 赋值运算符

- +=
- -=
- *=
- /=
- %=

#### 一元运算符

- `++`
- `--`

#### 比较运算符

- `<`
- `>`
- `>=`
- `<=`
- `==`: 值是否相等
- `===`：类型和值是否都相等
- `!==`：是否不全等

#### 逻辑运算符

- `&&`
- `||`
- `!`

### 流程控制语句

- if
  - 除了0，所有的数字都为真
  - 除了''，所有字符串都为真

- switch case

  - 数据和值必须满足全等`===`

  - ```js
    switch (数据) {
      case 值1:
        代码1
        break
      case 值2:
        代码2
        break
      default:
        代码n
    }
    ```

  - 

- 三元运算符

### 循环控制语句

- while
- for
- break/continue

### 函数

```js
function 函数名(参数列表) {
  函数体
}
```

- 命名 小驼峰

- return
  - 没有return 默认返回undefined

### 作用域

- 全局变量
  - 局部变量或块级变量 没有let声明直接赋值的当全局变量看（不提倡）
- 局部变量



### 匿名函数

- 函数表达式：把匿名函数赋值给一个变量，通过变量名调用

  - ```js
    let fn = function () {}
    ```

- 立即执行函数

  - ```js
    (function() {...})();
    (function() {...})();
    ---
    (function(x, y) {
      console.log(x + y)
    })(1, 3)
    ```

  - 前一个括号声明，后一个括号调用

  - 分号

### 逻辑中断

- 短路：只存在`&&`和`||`中，当满足一定条件会让右边代码不执行
  - `&&`：左边为false就短路
  - `||`：左边为true就短路

### 转换boolean

- "": false
- 0: false
- undefined: false
- null: false
- NaN: false

- "" + 1 = 1
- null经过数字转换会变0
- undefined经过数字转换会变NaN

## Web APIs

### DOM

#### 获取DOM元素

- document.querySelector(CSS选择器)：获取匹配的第一个元素
- document.querySelectorAll(CSS选择器)：获取匹配的多个元素

#### 操作元素内容

- 对象.innerText

- 对象.innerHTML

- 对象.属性=值

  - ```js
    const image = document.querySelector('img')
    image.src = 'xxx.jpg'
    image.title = '123'
    ```

- 对象.style.样式属性=值

  - ```js
    box.style.width = '300px'
    box.backgroundColor = 'pink' //小驼峰
    ```

- 通过类名修改属性，会覆盖

  - ```js
    //定义好类对应的属性，给对象添加类名
    对象.className = 类名
    ```

- 通过classList操作类控制CSS，用于追加和删除

  - ```js
    元素.classList.add(类名)//追加
    元素.classList.remove(类名)//删除
    元素.classList.toggle(类名)//切换
    ```

- 自定义属性

  - H5中推出的data-自定义属性

  - 在标签上一律以`data-`开头

  - DOM对象上一律以`dataset`对象方式获取

  - ```html
    <body>
      <div class="box" data-id="10">盒子</div>
      <script>
        const box = document.querySelector('.box')
        console.log(box.dataset.id)
      </script>
    </body>
    ```

#### 事件监听

- 元素对象.addEventListener('事件类型', 要执行的函数)

> 元素.on事件：也可以添加事件监听，但会被覆盖，且只能冒泡 不能捕获，addEventListener不会被覆盖，能冒泡 也能捕获。

- 事件类型
  - 鼠标事件
    - click
    - mouseenter: 没冒泡，只会在鼠标进入目标元素时触发一次
    - mouseover：有冒泡，事件在鼠标经过目标元素或任何子元素时会不断触发
    - mouseleave
    - mousemove: 鼠标移动
  - 焦点事件
    - focus
    - blur
  - 键盘事件
    - keydown
    - keyup
  - 文本事件
    - input

#### 事件对象

事件对象中有事件触发时的相关信息，例如鼠标点击时的位置，键盘按下时的键位

```js
btn.addEventListener('click', function(e){
  console.log(e)
})
```

##### 常用对象属性

- type：事件类型
- clientX/clientY:光标相对于浏览器可见窗口左上角的位置
- offsetX/offsetY：光标相对于当前DOM元素左上角的位置
- key：用户按下的键盘的值，现在不提倡使用keyCode



#### 环境对象

指的是函数内部特殊的变量`this`，它代表着当前函数运行时所处的环境

- 函数的调用方式不同，`this`的指代对象也不通
- `this`指向的粗略规则是谁调用指向谁（addEventListener指向绑定的元素，普通函数指向window）



#### 回调函数

函数A作为参数传递给函数B，A就被称为回调函数

#### 事件流

事件流指的是事件完整执行过程中的流动路径

##### 事件捕获

DOM的根元素开始去执行对应的事件（从父元素到子元素）

```js
DOM.addEventListener(事件类型, 函数, 是否使用捕获机制)
```

> L0事件只有冒泡，没有捕获

##### 事件冒泡

当一个元素的事件被触发时，同样的事件会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡（从子元素到父元素）

- 简单理解：当一个元素触发事件后，会依次向上调用所有父级元素的**同名事件**

- 事件冒泡是默认存在的

##### 阻止事件传播

- 事件对象.stopPropagation()
- 阻断事件流动传播，既能阻止冒泡，也能阻止捕获

```js
btn.addEventListener('click', function(e){
  e.stopPropagation()
})
```

##### 解绑事件

- on事件方式

  - ```js
    // 绑定事件
    btn.onClick = function(e){
      console.log(e)
    }
    // 解绑事件
    btn.onClick = null
    ```

- addEventListener方式

  - ```js
    function fn(e){
      console.log(e)
    }
    //绑定事件
    btn.addEventListener('click', fn)
    //解绑事件
    btn.removeEventListener('click', fn)
    ```

  - 匿名函数无法解绑

##### 事件委托

事件委托是利用事件流特征解决开发问题的技巧，可以减少事件注册次数，提高程序性能，原理是利用事件冒泡特点，给父元素注册事件，当触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件



##### 阻止元素默认行为

`e.preventDefault()`

##### 其他事件

- 页面加载事件

  - 外部资源加载完毕时触发的事件

    - 等待页面所有资源加载完毕，执行回调函数：`window.addEventListener('load', function() {})`

      > 也可以针对某个资源绑定事件：img.addEventListener('load', function() {}) 

  - 初始HTML文档被完全加载和解析完成后，DOMContentLoaded事件被触发，无需等待样式表、图像等完全加载

    - `document.addEventListener('DOMContentLoaded', function() {})`

- 页面滚动事件

  - 滚动条在滚动的时候持续触发的事件

    - `window.addEventListener('scroll', function() {})`
    - 给window或document添加scroll事件
    - 也可以监听某个元素内部滚动

  - 获取滚动位置

    - scrollLeft**（可读写）**

    - scrollTop**（可读写）**

    - ```js
      window.addEventListener('scroll', function() {
        const n = document.documentElement.scrollTop
        console.log(n)
      })
      ```

      > document.documentElement返回对象为HTML元素
      >
      > <html lang="en">
      >
      > <head>...</head>
      >
      > <body>...</body>
      >
      > </html>

  - 滚动到指定坐标
    - scrollTo(x, y)

- 页面尺寸事件

  - 窗口尺寸改变时触发的事件`resize`
    - `window.addEventListener('resize', function() {})`
  - 获取元素可见部分的宽高`clientWidth`、`clientHeight`
    - 不包含border，margin，滚动条

#### 元素尺寸位置

##### 获取宽高

- offsetWidth和offsetHeight
- 获取元素自身的宽高，包含padding，border
- 结果是数值
- 获取的是可视宽高，如果盒子隐藏，结果是0

##### 获取位置

- offsetLeft和offsetTop
- 获取元素距离自己**定位**父级元素的左、上距离，**只读属性**

##### 获取元素大小及其相对视口的位置

- `element.getBoundingClientRect()`

#### 日期对象

- 实例化
  - `const date = new Date()`
  - `const date = new Date('2023-4-8 08:00:00')`

- 常用方法
  - getFullYear():四位数年份
  - getMonth():月份，范围0-11
  - getDate():获取月份中的每一天
  - getDay():获取星期，0-6
  - getHours():小时，0-23
  - getMinutes():分钟，0-59
  - getSeconds():秒，0-59
  - toLocaleString(): yyyy/m/d HH:mm:ss
- 时间戳
  - `date.getTime()`
  - `+new Date()`
  - `Date.now()`

#### DOM节点

##### 节点类型

- 元素节点
- 属性节点
- 文本节点
- 其他（注释、文档类型、CDATA、实体引用、处理指令。。。）

##### 查找节点

- 父节点
  - 元素.parentNode
- 子节点
  - 元素.childNodes：获取所有子节点，包括文本（空格、换行）、注释节点等
  - 元素.children：仅获取元素节点，返回的是一个伪数组
- 兄弟节点
  - nextElementSibling：下一个兄弟节点
  - previousElementSibling:上一个兄弟节点

##### 新增节点

###### 创建节点

- `const div = document.createElement('div')`

###### 追加节点

- `父元素.appendChild(div)`

- `父元素.insertBefore(要插入的元素, 在哪个元素前面)`：插入某个元素之前
  - 例：`ul.insertBefore(li, ul.children[0])`

###### 克隆节点

- 元素.cloneNode(布尔值)
  - true：克隆时会包含后代节点一起克隆
  - false：不包含后代节点，默认值

##### 删除节点

- `父元素.removeChild(子元素)`



### BOM

#### 组成

BOM（Browser Object Model）是浏览器对象模型，包含：navigator、location、document、history、screen

window是一个全局对象，document、alert()、console.log()都是window的属性

- 所有通过`var`定义在全局作用域中的变量、函数都会变成window对象的属性和方法
- window对象下的属性和方法调用的时候可以省略window

#### 定时器

##### 延时函数

- `let timer = setTimeout(回调函数, 等待时间ms)`，返回id，setTimeout只执行一次
- 关闭：`clearTimeout(timer)`

##### 间歇函数

- `let interval = setInterval(函数, 间隔时间ms)`，返回的是的是一个id数字，不断执行
- 关闭：`clearInterval(interval)`

#### 事件循环

js是单线程，所有任务需要排队。HTML5提出了Web Worker标准，允许JavaScript脚本创建多个线程。于是JS出现了同步和异步。

- 同步任务：都在主线程执行，形成执行栈
- 异步任务：通过回调函数实现，异步任务添加到任务队列中，一般异步任务有以下三种类型
  - 普通事件：click、resize等
  - 资源加载：load、error等
  - 定时器：setTimeout、setInterval等

##### 执行机制

1. 先执行执行栈中的同步任务
2. 异步任务放到任务队列中
3. 执行栈中的所有同步任务执行完毕，系统会按次序读取任务队列中的异步任务，被读取的异步任务结束等待状态，进入执行栈，开始执行

#### location

localtion的数据类型是对象，它拆分保存了URL地址的各个组成部分

- `location.href`：常用于页面跳转

- `location.search`:获取地址中携带的参数，符号`?`后面的部分
- `location.hash`:获取地址中的hash值，符号`#`后面的部分
- `location.reload()`：用来刷新当前页面，传入参数true时强制刷新

#### navigator

navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息

- navigator.userAgent:检测浏览器版本和平台

#### history

history数据类型是对象，主要管理历史记录，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等

- history.back()
- history.forward()
- history.go(参数): 1->前进一个页面，-1->后退一个页面

#### 本地存储

##### 介绍

数据存储在用户浏览器中，设置、读取方便，刷新页面不会丢失数据，sessionStorage和localStorage约5M

##### 分类

- localStorage
  - 可以多窗口（页面）共享（同一浏览器可以共享）
  - 键值对形式存储使用
  - 语法
    - 存储：`localStorage.setItem(key, value)`
    - 查询：`localStorage.getItem(key)`
    - 删除：`localStorage.removeItem(key)`
- sessionStorage
  - 生命周期到关闭浏览器窗口截止
  - 在同一个窗口（页面）下数据可以共享
  - 键值对形式存储使用
  - 用法api和`localStorage`一致

##### 存储复杂数据类型

把复杂数据类型转成字符串形式存储

- `JSON.stringify`
- `JSON.parse`

#### 数组map和join

##### map

- 遍历数组处理数据，返回新的数组

- ```js
  const arr = ['red', 'blue']
  const newArr = arr.map(function(ele, index) {
    return ele + '颜色'
  })
  console.log(newArr) // ['red颜色', 'blue颜色']
  ```

##### join

- 把数组所有元素转换为一个字符串
- `const newStr = join(字符串)`:元素用指定字符串相连

## 进阶

### 正则表达式

- 定义：`const reg = /表达式/`
- 判断是否匹配：`reg.test(被检测字符串)`，匹配返回true，否则false
- 查找：`reg.exec(被检测字符串)`，找到返回数组，否则为null

#### 元字符

- 边界符
  - `^`：开始
  - `$`：结束
- 量词
  - `*`：0或多次
  - `+`：1或多次
  - `?`：0或1次
  - `{n}`：重复n次
  - `{n,}`：重复n次或更多
  - `{n,m}`：重复n次到m次
- 字符类
  
  - `[]`：匹配字符集合，匹配任一个都是true
  - `[a-zA-Z]`：字母
  - `[^a-z]`：[]中的^表示取反
  - `.`：除换行之外的任何单个字符
  - `\d`：数字
  - `\D`：所有0-9以外字符，等于`[^0-9]`
  - `\w`：任一字母、数字、下划线，相当于`[a-zA-Z0-9_]`
  - `\W`：匹配除字母、数字、下划线之外的字符，相当于`[^a-zA-Z0-9_]`
  - `\s`：匹配空格（包括制表符、换行符、空格符等）,相当于`[\t\r\n\v\f]`
  - `\S`：匹配非空格，相当于`[^\t\r\n\v\f]`

#### 修饰符

- 语法：`/表达式/修饰符`

- 修饰符：
  - i：ignore，匹配时，不区分大小写
  - g：global，匹配所有满足正则的结果

#### 替换

- 语法：`字符串.replace(/正则表达式/， 替换的文本)`，返回替换后的字符串



### 作用域

- 局部作用域

- 全局作用域

- 作用域链

- JS垃圾回收机制

  - 全局变量一般不会回收（关闭页面回收）
  - 一般情况下局部变量的值不再被使用会被自动回收
  - 内存由于某种原因未释放或无法释放会内存泄漏
  - 栈：由操作系统自动分配释放函数的参数值、局部变量等基本数据类型放在栈里
  - 堆：一般由开发分配释放，若开发不释放由垃圾回收机制回收。复杂数据类型放在堆里。

  > 引用计数法（有循环引用问题）
  >
  > - 定义“内存不再使用”，看一个对象是否有指向它的引用，没有引用就回收对象
  >   - 根据记录被引用的次数
  >   - 被引用一次，就+1，多次引用会累加
  >   - 如果减少一个引用就-1
  >   - 如果引用次数是0，则释放内存
  >
  > 标记清除法
  >
  > - 将不再使用的对象定义为无法达到的对象
  > - 从根部（JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，都是还需要使用的
  > - 无法由根部出发触及的对象标记为不再使用，稍后进行回收

- 闭包

  - 和python中的闭包一样:`如果在一个外部函数中定义一个内部函数，内部函数对外部作用域的变量进行引用，外部函数的返回值是内部函数，这样的函数就被认为是闭包(closure)。`

- 变量提升

  - 允许变量在声明之前即被访问（var声明变量）
  - js会在执行之前把当前作用域下var声明的变量提升到当前作用域的最前面，只提升声明，不提升赋值

- 函数提升

  - 代码执行前会把所有函数声明提升到当前作用域的最前面
  - 只提升声明，不提升调用

> 函数表达式特殊,必须先声明赋值后调用

### 函数进阶

- 动态参数：`arguments`，只存在于函数里，伪数组

- 剩余参数：`function getSum(paramA, paramB, ...arr)`,arr是个真数组

- 展开运算符：`...`能将一个数组进行展开

  - ```js
    const arr = [1,5,3]
    console.log(...arr)// 1 5 3
    ```

  - 用于求数组最大/小值`Math.max(...arr)`

  - 用于合并数组：const arr = [...arr1, ...arr2]

#### 箭头函数

引入箭头函数是为了更简洁的写法，适用于需要匿名函数的地方

```js
const fn = () => {}
const fn = x => { console.log(x) }
const fn = x => console.log(x)
const fn = x => x * 2
const fn = (uname) => ({ uname: uname }) //返回一个对象
```

##### 箭头函数的this

**箭头函数不会创建自己的this对象，它只会从自己的作用域链的上一层**

### 解构赋值

#### 数组解构

数组结构是将数组的单元值快速批量赋值给一系列变量的简洁语法

- `const [max, min, avg] = [100, 60, 80]`
- 典型用法：交换两个变量
- 可以设置默认值
- 可以用剩余参数防止undefined传递
- 可以忽略某些值`const [a, ,c, d] = [1, 2, 3, 4]`



> js必须加分号场景：
>
> 1. 两个连续的立即执行函数
> 2. 使用数组

#### 对象解构

对象解构是将对象的属性和方法快速批量赋值给一系列变量的简介语法

- ```js
  const user = {
    name: '小明',
    age: 18
  }
  const {name, age} = user
  ```

- 对象的属性值将会被赋值给与属性名相同的变量

- 对象中找不到与变量名一致的属性时变量值为undefined

- 数组对象解构

  ```js
  const pig = [
    {
      name: '佩奇',
      age: 6
    }
  ]
  
  const [{ name, age }] = pig
  console.log(name,age)
  ```

- 多级对象解构

  ```js
  const pig = {
    name: '佩奇',
    age: 6,
    family: {
      mother: 'mon',
      father: 'dad'
    }
  }
  
  const { name, family: { mother, father }} = pig
  ```

  

### 对象

#### 创建对象的方式

- 字面量创建

- 构造函数
  - 命名以大写字母开头
  - 只能由`new`操作符来执行
  - 实例化执行过程
    - 创建新对象
    - 构造函数this指向新对象
    - 执行构造函数代码，修改this，添加属性
    - 返回新对象

#### 实例成员&静态成员

- 实例成员：构造函数创建的对象为实例对象，实例对象的属性和方法称为实例成员
- 静态成员：构造函数的属性和方法称为静态成员
  - 静态成员只能由构造函数访问
  - 静态方法中的this指向构造函数
  - `Date.now()、Math.PI、Math.random()`

#### 内置构造函数

- Object
  - Object.keys()
  - Object.values()
  - Object.assign(dest, source)
- Array
  - 实例方法：forEach、filter、map、reduce、join、find、every、some、concat、splice、reverse、findIndex...
  - 伪数组转换为真数组：Array.from()
- String
  - 实例属性、方法：length、split()、substring()、startsWith()、includes()、toUpperCase()、toLowerCase()、indexOf()、endsWith()、replace()、match()...
- Number
  - toFixed()设置保留小数位数

### 原型Prototype

- 构造函数通过原型分配的函数是所有对象所共享的。
- JavaScript每一个构造函数都有一个`prototype`属性，指向另一个对象，所以也称为原型对象
- prototype对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存
- 可以把不变的方法直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法
- 构造函数和原型对象中的this都指向实例化的对象

#### constructor属性

每个原型对象里都有个constructor属性，该属性指向该原型对象的构造函数

#### 对象原型

每个对象都有一个属性`__proto__`，指向构造函数的prototype对象

- `__proto__`是JS非标准属性
- [[prototype]]和`__proto__`意义相同
- 用来表明当前实例对象指向哪个原型对象prototype
- `__proto__`对象原型里也有一个constructor属性，指向创建该实例对象的构造函数

#### 原型继承

通过原型可以继承公共属性

```js
const Person = {
  eyes: 2,
  nose: 1
}

function Man() {
  
}
Man.prototype = Person
Man.prototype.constructor = Man

---
  
const Person = {
  this.eyes: 2,
  this.nose: 1
}

function Man() {
  
}
Man.prototype = new Person()
```

#### 原型链

基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联关系是一种链状的解构，称为原型链

##### 查找规则

- 当访问一个对象的属性/方法时，首先查找这个对象自身有无该属性
- 如果没有就查找他的原型（`__proto__`指向的prototype对象)
- 如果还没有就查找原型对象的原型（Object的prototype）
- 依此类推一直到Object为止（null）
- `__proto__`对象原型的意义就在于为对象成员查找机制提供方向
- 可以使用`instanceof`运算符检测构造函数的`prototype`属性是否出现在某个实例对象的原型链上

### 深浅拷贝

深浅拷贝只针对引用数据类型

- 浅拷贝：如果是简单数据类型拷贝值，引用数据类型拷贝的是地址
  - 拷贝对象：Object.assign() / 展开运算符 {...obj}拷贝对象
  - 拷贝数组：Array.prototype.concat() 或者 [...arr]
- 深拷贝：拷贝的是对象，不是地址
  - 通过递归实现深拷贝
  - lodash中的`_.cloneDeep()`
  - JSON.stringify()

### 异常

#### 抛出异常

- throw msg
- throw new Error(msg)

#### 异常捕获

```js
try {
  
} catch (err) {
  
} finally {
  
}
```

#### debugger

`debugger`

### this

#### 普通函数

- 普通函数的调用方式决定了this的值，即**谁调用 this的值指向谁**

- 普通函数没有明确调用者时this的值为window，严格模式下没有调用者时this的值为undefined

#### 箭头函数

- 箭头函数中并不存在this
- 箭头函数会默认绑定外层this的值，所以在箭头函数中this的值和外层的this是一样的
- 箭头函数中的this引用的就是最近作用域中的this
- 向外层作用域中，一层一层查找this，直到有this的定义

#### 改变this指向

- fun.call(thisArg, arg1, arg2...)
  - thisArg：fun函数运营时指定的this值
  - arg1,arg2：传递的其他参数
- apply(thisArg, [argsArray])
  - thisArg：fun函数运营时指定的this值
  - argsArray：传递的值，必须包含在数组里
- bind()
  - bind不会调用函数，但能改变函数内部this的指向
  - fun.bind(thisArg, arg1, arg2...)
  - thisArg：fun函数运营时指定的this值
  - arg1,arg2：传递的其他参数
  - 返回由指定this值和初始化参数改造的**原函数的拷贝**

### 防抖（debounce）

- 单位时间内，频繁触发事件，只执行最后一次

- lodash库的`_.debounce(fun, 时间)`

#### 思路

1. 声明一个定时器
2. 每次触发事件都先判断是否有定时器，如果有先清除
3. 如果没有则开启定时器并保存变量
4. 在定时器中调用要执行的函数

```js
const box = document.querySelector('.box')
let i = 1
function mouseMove() {
  box.innerHTML = i++
}

function debounce(fn, t) {
  let timer
  return function() {
    if (timer) clearTimeout(timer)
    timer = setTimeout(function() {
      fn()
    }, t)
  }
}

box.addEventListener('mousemove', debounce(mouseMove, 500))
```

### 节流（throttle）

- 单位时间内，频繁触发事件，只执行一次
- lodash库的`_.throttle(fun, 时间)`

#### 思路

1. 声明一个定时器
2. 每次触发事件都判断是否有定时器，如果有则不开启新定时器
3. 如果没有定时器则开启定时器并保存变量
   1. 定时器里调用执行的函数
   2. 定时器里要把上一个定时器清空

```js
function throttle(fn, t) {
  let timer = null
  return function() {
    if(!timer) {
      timer = setTimeout(function(){
        fn()
        // setTimeout中无法删除定时器，因为定时器还在运作，所以不能用clearTimeout
        timer = null
      }, t)
    }
  }
}

box.addEventListener('mousemove', throttle(mouseMove, 500))
```

#### 案例：页面打开，记录上一次的视频播放位置

##### 两个事件

- ontimeupdate：事件在视频/音频当前播放位置发生改变时触发
- onloadeddata：事件在当前帧的数据加载完成且还没有足够的数据播放视频/音频的下一帧时触发

```js
video.ontimeupdadte = _.throttle(() => {
  localStorage.setItem('currentTime', video.currentTime)
}, 1000)

video.onloadeddata = () => {
  video.currentTime = localStorage.getItem('currentTime') || 0
}
```

