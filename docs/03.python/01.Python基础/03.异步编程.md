---
title: 异步编程
date: 2021-06-19 00:24:32
permalink: /pages/d507ca/
categories: 
  - python
  - Python基础
tags: 
  - 
---


# 异步编程



## 协程

协程，又称微线程，纤程。英文名Coroutine。是一种用户态的上下文切换技术。协程的作用是在执行函数A时可以随时中断去执行函数B，然后中断函数B继续执行函数A（可以自由切换）。但这一过程并不是函数调用，这一整个过程看似像多线程，然而协程只有一个线程执行。

### 协程的优势

- 效率极高，因为子程序切换不是线程切换，由程序自身控制，没有切换线程的开销，所以与多线程相比，线程的数量越多，协程的性能优势越明显。
- 不需要多线程的同步机制，因为只有一个线程，也不存在同时写变量的线程安全问题，在控制共享资源时也不需要加锁，因此执行效率高很多。

> 协程可以处理IO密集型程序的效率问题，但是CPU密集型不是它的长处，要充分发挥CPU的利用率可以结合多进程+协程

实现协程的方式：

- yield关键字
- asyncio装饰器
- async、await关键字（推荐）



## 事件循环

asyncio模块中，每一个进程都有一个事件循环。把一些函数注册到事件循环上，当满足事件发生的时候，调用相应的协程函数

> 事件循环的作用是管理所有的事件，在整个程序运行过程中不断循环执行，追踪事件发生的顺序将它们放到队列中，当主线程空闲的时候，调用相应的事件处理者处理事件。

伪代码：

```python
任务列表 = [任务1,任务2,任务3...]

while true:
    可执行的任务列表,已完成的任务列表 = 检查所有任务,将可执行的和已完成的任务返回
    for 就绪任务 in 可执行的任务:
        执行就绪任务
        
    for 已完成的任务 in 已完成的任务:
        剔除已完成的任务
        
    如果任务列表的全部任务都已完成,终止循环
```

```python
import asyncio


# 生成或获取一个事件循环
loop = asyncio.get_event_loop()
# 将任务放到任务列表
loop.run_until_complete(任务)
```

###  

## 协程函数

定义函数时，如果是`async def 函数`的函数，就是一个协程函数

## 协程对象

执行协程函数得到的对象

::: tip

执行协程函数创建协程对象，函数内部代码不会立即执行

如果想运行协程函数内部代码，必须将协程对象交给事件循环处理

:::

```python
import asyncio


# 定义一个协程函数
async def func():
    print("异步编程")


# 生成一个事件循环
loop = asyncio.get_event_loop()
# 得到协程对象
res = func()
# 将协程对象交给事件循环
loop.run_until_complete(res)
# asyncio.run(res)

res:
异步编程
```

如果不把协程对象放入事件循环

```python
import asyncio


# 定义一个协程函数
async def func():
    print("异步编程")


# 生成一个事件循环
loop = asyncio.get_event_loop()
# 得到协程对象
res = func()

res:
sys:1: RuntimeWarning: coroutine 'func' was never awaited
```

## await关键字

await + 可等待的对象（协程对象、Future对象、Task对象 -> io等待）

```python
import asyncio


async def func():
    print('异步编程')
    response = await asyncio.sleep(2)
    print("结束",response)
    
asyncio.run(func())
```

示例:

```python
import asyncio


async def others():
    print('start')
    await asyncio.sleep(2)
    print('end')
    return '返回值'


async def func():
    print('执行协程函数内部代码')
    # 遇到IO操作挂起当前协程,等到IO完成后继续运行,当前协程挂起时,事件循环可以执行其他协程
    response = await others()
    print(f'IO的结果是:{response} ')

asyncio.run(func())

res:
执行协程函数内部代码
start
end
IO的结果是:返回值 
```



## Task对象

Tasks用于并发调度协程，是对协程对象的一种封装，其中包含了任务的各个状态。通过`asyncio.create_task()`函数创建Task对象，这样可以让协程加入事件循环中等待调度执行。还可以使用低层级的`loop.create_task()`或`asyncio.ensure_future()`函数。不建议手动实例化Task对象。

示例1：

```python
import asyncio


async def func():
    print(1)
    await asyncio.sleep(2)
    print(2)
    return '返回值'


async def main():
    print('main函数开始')

    # 创建task对象,将当前执行func函数的任务添加到事件循环
    task1 = asyncio.create_task(func())

    task2 = asyncio.create_task(func())

    print('main函数结束')

    # 当执行某协程遇到IO操作,会自动切换执行其他任务
    res1 = await task1
    res2 = await task2
    print(res1, res2)


asyncio.run(main())

res:
main函数开始
main函数结束
1
1
2
2
返回值 返回值
```

示例2：

```python
import asyncio


async def func():
    print(1)
    await asyncio.sleep(2)
    print(2)
    return '返回值'


async def main():
    print('main函数开始')

    
    task_list = [
       asyncio.create_task(func()),
       asyncio.create_task(func())
    ]
    print('main函数结束')
    done,pending = await asyncio.wait(task_list,timeout=None)
    print(done)
asyncio.run(main())
```

## asyncio.Future对象

Task继承了Future,Task对象内部await的结果的处理基于Future对象

```python
async def main():
    loop = asyncio.get_running_loop()
    _future = loop.create_future()
    await _future
asyncio.run(main())
```

## concurrent.futures.Future对象

使用线程池/进程池实现异步操作时用到的对象

```python
import time
from concurrent.futures import Future
from concurrent.futures.thread import ThreadPoolExecutor

def func(value):
    time.sleep(1)
    print(value)
    return 123

pool = ThreadPoolExecutory(max_workers=5)
for i in range(5)
	fut = pool.submit(func,1)
    print(fut)
```

