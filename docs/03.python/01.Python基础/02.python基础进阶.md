---
sidebarDepth: 2
title: python基础进阶
date: 2021-06-19 00:24:32
permalink: /pages/f275de/
categories: 
  - python
  - Python基础
tags: 
  - 
---

# python基础进阶

## 网络编程

### 简单的server/client模拟

#### server端

```python
import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', 8000))
server.listen()
sock, addr = server.accept()


data = sock.recv(1024)
print(data.decode('utf-8'))
sock.send('hello {}'.format(data.decode('utf-8')).encode('utf-8'))
server.close()
sock.close()
```

#### client端

```python
import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(('127.0.0.1', 8000))
client.send('tom'.encode('utf-8'))
data = client.recv(1024)
print(data.decode('utf-8'))
client.close()
```



启动服务端和客户端后:

```bash
#服务端:
tom

#客户端
hello tom
```

### socket模拟http请求

```python
import socket
from urllib.parse import urlparse


def get_url(url):
    # 通过socket请求
    url = urlparse(url)
    host = url.netloc
    path = url.path
    if path == "":
        path = "/"
    # 建立socket连接
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client.connect((host, 80))

    client.send("GET {} HTTP/1.1\r\nHost:{}\r\nConnection:close\r\n\r\n".format(path, host).encode("utf-8"))
    data = b""
    while True:
        d = client.recv(1024)
        if d:
            data += d
        else:
            break

    data = data.decode("utf-8")
    html_data = data.split("\r\n\r\n")[1]
    print(html_data)
    client.close()

if __name__ == '__main__':
    get_url("https://www.baidu.com")

```

结果:

```bash
<!DOCTYPE html><!--STATUS OK-->
<html>
<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=Edge">
	<link rel="dns-prefetch" href="//s1.bdstatic.com"/>
	<link rel="dns-prefetch" href="//t1.baidu.com"/>
	<link rel="dns-prefetch" href="//t2.baidu.com"/>
	<link rel="dns-prefetch" href="//t3.baidu.com"/>
	<link rel="dns-prefetch" href="//t10.baidu.com"/>
	<link rel="dns-prefetch" href="//t11.baidu.com"/>
	<link rel="dns-prefetch" href="//t12.baidu.com"/>
	<link rel="dns-prefetch" href="//b1.bdstatic.com"/>
	<title>百度一下，你就知道</title>
	<link href="http://s1.bdstatic.com/r/www/cache/static/home/css/index.css" rel="stylesheet" type="text/css" />
	<!--[if lte IE 8]><style index="index" >#content{height:480px\9}#m{top:260px\9}</style><![endif]-->
	<!--[if IE 8]><style index="index" >#u1 a.mnav,#u1 a.mnav:visited{font-family:simsun}</style><![endif]-->
	<script>var hashMatch = document.location.href.match(/#+(.*wd=[^&].+)/);if (hashMatch && hashMatch[0] && hashMatch[1]) {document.location.replace("http://"+location.host+"/s?"+hashMatch[1]);}var ns_c = function(){};</script>
	<script>function h(obj){obj.style.behavior='url(#default#homepage)';var a = obj.setHomePage('//www.baidu.com/');}</script>
	<noscript><meta http-equiv="refresh" content="0; url=/baidu.html?from=noscript"/></noscript>
	<script>window._ASYNC_START=new Date().getTime();</script>
</head>
<body link="#0000cc"><div id="wrapper" style="display:none;">
.......
</body></html>
```



## 并发编程

### 多线程的两种实现方式

#### 通过threading模块的Thread类

```python
import time
import threading


# 1.通过threading模块的Thread类直接实例化线程对象
def get_detail_html(url):
    print("get_detail_html_started")
    time.sleep(4)
    print("get_detal_html end")


def get_detail_url(url):
    print("get_detail_url_started")
    time.sleep(2)
    print("get_detail_url_end")

    
if __name__ == '__main__':
    thread1 = threading.Thread(target=get_detail_html, args=("",))
    thread2 = threading.Thread(target=get_detail_url, args=("",))
    start_time = time.time()
    print(start_time)
    # 当主线程退出时,子线程kill掉 -> 和java一样 setDaemon
    thread1.setDaemon(True)
    thread1.start()
    thread2.start()
    # 先执行其他线程再执行当前线程 -> 和java一样 join
    # 主线程会等两个子线程执行完毕才执行
    thread1.join()
    thread2.join()
    print("last time : {}".format(time.time() - start_time))
```

#### 通过继承Thread类

```python
import time
import threading

class GetDetailHtml(threading.Thread):
    def __init__(self, name):
        super().__init__(name=name)

    print("get_detail_html_started")
    time.sleep(4)
    print("get_detal_html end")


class GetDetailUrl(threading.Thread):
    def __init__(self, name):
        super().__init__(name=name)

    print("get_detail_url_started")
    time.sleep(2)
    print("get_detail_url_end")


if __name__ == '__main__':
    thread1 = GetDetailHtml('thread1')
    thread2 = GetDetailUrl('thread2')
    start_time = time.time()
    print(start_time)
    # 当主线程退出时,子线程kill掉 -> 和java一样 setDaemon
    thread1.setDaemon(True)
    thread1.start()
    thread2.start()
    # 先执行其他线程再执行当前线程 -> 和java一样 join
    # 主线程会等两个子线程执行完毕才执行
    thread1.join()
    thread2.join()
    print("last time : {}".format(time.time() - start_time))
```



**其它:** 

`thread1 = threading.Thread(target=get_detail_html, args=("",)) `这种写法中,args参数之所只有一个`""`空串传入但要加`,`是因为python的语法为了区分单个数据元组和单个数据的,如果写成(3,)会被认为是一个元组,如果是(3),就无法区分是元组还是int类型的3.

:::warning

元组中只包含一个元素时，需要在元素后面添加逗号。

:::



### 线程同步

#### 使用 Thread 对象的 Lock 实现

```python
import threading
import time


class MyThread(threading.Thread):
    def __init__(self, thread_id, name, counter):
        super().__init__(name=name)
        self.name = name
        self.thread_id = thread_id
        self.counter = counter

    def run(self):
        print("开启线程: " + self.name)
        # 获取锁.用于线程同步
        my_lock.acquire()
        print_time(self.name, self.counter, 3)
        # 释放锁
        my_lock.release()


def print_time(thread_name, delay, counter):
    while counter:
        time.sleep(delay)
        print(f"#{thread_name}: {time.ctime(time.time())}")
        counter -= 1


my_lock = threading.Lock()
threads = []
# 创建新线程
thread1 = MyThread(1, "Thread-1", 1)
thread2 = MyThread(2, "Thread-2", 2)
thread1.start()
thread2.start()
# 添加到线程列表
threads.append(thread1)
threads.append(thread2)

for t in threads:
    t.join()
print("退出主线程")


```

结果:

```bash
开启线程: Thread-1
开启线程: Thread-2
#Thread-1: Mon Apr 12 21:54:42 2021
#Thread-1: Mon Apr 12 21:54:43 2021
#Thread-1: Mon Apr 12 21:54:44 2021
#Thread-2: Mon Apr 12 21:54:46 2021
#Thread-2: Mon Apr 12 21:54:48 2021
#Thread-2: Mon Apr 12 21:54:50 2021
退出主线程
```



#### 线程优先级队列实现

```python
import queue
import threading
import time

exitFlag = 0


class MyThread(threading.Thread):
    def __init__(self, thread_id, name, q):
        super().__init__(name=name)
        self.threadId = thread_id
        self.name = name
        self.q = q

    def run(self):
        print("开启线程: " + self.name)
        process_data(self.name, self.q)
        print("退出线程: " + self.name)


def process_data(name, q):
    while not exitFlag:
        queueLock.acquire()
        if not workQueue.empty():
            data = q.get()
            queueLock.release()
            print(f"{name} processing {data}")
        else:
            queueLock.release()
        time.sleep(1)


threadList = ["Thread-1", "Thread-2", "Thread-3"]
queueLock = threading.Lock()
nameList = ["ONE", "TWO", "THREE", "FOUR", "FIVE"]
workQueue = queue.Queue(10)
threads = []
threadId = 1

for tname in threadList:
    thread = MyThread(threadId, tname, workQueue)
    thread.start()
    threads.append(thread)
    threadId += 1

queueLock.acquire()
for name in nameList:
    workQueue.put(name)
queueLock.release()

while not workQueue.empty():
    pass

exitFlag = 1

for t in threads:
    t.join()

print("主线程退出")
```

运行结果:

```bash
开启线程: Thread-1
开启线程: Thread-2
开启线程: Thread-3
Thread-1 processing ONE
Thread-2 processing TWO
Thread-3 processing THREE
Thread-2 processing FOUR
Thread-1 processing FIVE
退出线程: Thread-2
退出线程: Thread-1
退出线程: Thread-3
主线程退出
```



### 线程池

```python
from concurrent.futures import ThreadPoolExecutor, as_completed
import time


def get_data(times):
    time.sleep(times)
    print("get data {} success".format(times))


thread_pool = ThreadPoolExecutor(max_workers=2)
task1 = thread_pool.submit(get_data, 3)
task2 = thread_pool.submit(get_data, 2)

datas = [1, 2, 3]
# subit后直接返回
all_tasks = [thread_pool.submit(get_data, data) for data in datas]
# as_complete底层是生成器
# for future in as_completed(all_tasks):
#    res = future.result()
#    print(res)
for data in thread_pool.map(get_data, datas):
    print("get {} data ".format(data))

```

线程池：

- 主线程可以获取某一个线程的状态或任务的状态及返回值
- 当一个线程完成的时候能立刻知道
- futures可以让多线程和多进程编码接口一致



## 多进程编程

对于io操作来说，使用多线程

对于耗cpu的操作，用多进程

- 进程的切换代价高于多线程

```python
from concurrent.futures import ProcessPoolExecutor
import multiprocessing
import time


# 多进程编程
def get_html(n):
    time.sleep(n)
    return n


if __name__ == '__main__':
    # progress = multiprocessing.Process(target=get_html, args=(2,))
    # print(progress.pid)
    # progress.start()
    # print(progress.pid)
    # progress.join()
    # print('main progress end')

    # 使用进程池
    pool = multiprocessing.Pool(multiprocessing.cpu_count())
    # res = pool.apply_async(get_html, args=(3,))
    # 不再接受任务
    # pool.close()
    # 等待所有任务完成
    # pool.join()
    # print(res)
    # print(res.get())

    # imap 按顺序
    # for res in pool.imap(get_html, [1, 5, 3]):
    #    print("{} sleep success".format(res))
    # imap_unordered 按完成时间
    for res in pool.imap_unordered(get_html, [1, 5, 3]):
        print("{} sleep success".format(res))
```



### 进程间通信

- 使用multiprocessing中的Queue 用法和threading的Queue类似
- 全局共享变量不适用与进程间通信（进程间的数据是隔离的）
- multiprocessing中的Queue不能用于进程池pool中的进程通信
- pool中的进程间通信需要使用multiprocessing中的Manager实例化后的queue（Manager().Queue())
- 使用Pipe管道实现进程间通信 receive，send = Pipe() 只能适用于两个进程间通信
- Manager().dict()等数据结构进行进程间通信

## python高级语法

### 函数式编程

函数式编程的思维各种语言都一样，python提供的有`filter()`，`map()`这类函数

### 闭包

简单的说，返回值是一个函数的函数就是闭包，通过闭包可以创建一些只有当前函数才能访问的变量，可以将一些私有的数据藏到闭包中

#### 形成闭包的条件

- 函数嵌套
- 将内部函数作为返回值返回
- 内部函数必须要使用到外部函数的变量



### 装饰器

思想上就是设计模式中的装饰器模式，在不修改原有函数的基础上进行功能的增强。

例如decorator就是一个装饰器：

```python
def func_add(a, b):
    return a + b


def decorator(func):
    def decorate_func(*args, **kwargs):
        print("这是一个方法的前置增强")
        res = func(*args, **kwargs)
        print(f"被增强的方法执行了,结果是{res}")
        print("这是一个方法的后置增强")
        return res

    return decorate_func


my_func = decorator(func_add)
res_func = my_func(123, 456)
print(f"最终的返回值是{res_func}")
```

执行结果：

```bash
这是一个方法的前置增强
被增强的方法执行了,结果是579
这是一个方法的后置增强
最终的返回值是579
```

#### 装饰器的典型用法

```python
def decorator(func):
    def decorate_func(*args, **kwargs):
        print("这是一个方法的前置增强")
        res = func(*args, **kwargs)
        print(f"被增强的方法执行了,结果是{res}")
        print("这是一个方法的后置增强")
        return res

    return decorate_func

@decorator
def say_hello():
    print("hello")
    
say_hello()
```

结果:

```bash
这是一个方法的前置增强
hello
被增强的方法执行了,结果是None
这是一个方法的后置增强
```

@property装饰器:

- 用来将get方法转换为对象的属性
- 使用property装饰的方法必须和属性名一样

@属性名.setter:

- setter方法的装饰器,@属性名.setter