---
title: golang基础语法
date: 2023-06-25 22:24:49
permalink: /pages/2c6d76/
categories:
  - go
  - Golang基础
tags:
  - 
---
# Golang基础语法

## 第一个Go程序

```go
package main

import "fmt"

func main() {
	fmt.Println("Hello, World!")
}
```

## 关键字

- `package`：定义当前源码文件所属的包。
- `import`：导入其他包。
- `func`：定义函数。
- `var`：声明变量。
- `const`：声明常量。
- `type`：定义类型。
- `struct`：定义结构体。
- `interface`：定义接口。
- `map`：定义映射类型。
- `range`：用于循环迭代。
- `select`：用于通道操作。
- `defer`：延迟执行。
- `go`：启动一个新的 goroutine。
- `chan`：定义通道类型。
- `default`：select 语句中的默认情况。
- `fallthrough`：在 switch 语句中贯穿到下一个 case。
- `if`：条件语句。
- `else`：if 语句中的默认情况。
- `switch`：多分支条件语句。
- `case`：switch 语句中的分支情况。
- `for`：循环语句。
- `break`：跳出循环或 switch 语句。
- `continue`：结束当前循环，开始下一次循环。
- `return`：返回函数结果。
- `panic`：抛出异常。

## 变量与常量

### 变量

#### 声明变量不赋值

```go
package main

import "fmt"

func main() {
	var a int
	fmt.Println("a = ", a)
	fmt.Printf("a的类型是%T\n", a)
}
// a = 0
// a的类型是int
```

#### 声明变量并初始化

```go
package main

import "fmt"

func main() {
	var a int = 10
	fmt.Println("a =", a)
	fmt.Printf("a的类型是%T\n", a)

	var b string = "hello"
	fmt.Println("b =", b)
	fmt.Printf("b的类型是%T\n", b)
}
// a = 10
// a的类型是int
// b = hello
// b的类型是string
```

#### 声明变量省略类型

```go
package main

import "fmt"

func main() {
	var a = 10
	fmt.Println("a =", a)
	fmt.Printf("a的类型是%T\n", a)

	var b = "hello"
	fmt.Println("b =", b)
	fmt.Printf("b的类型是%T\n", b)
}
// a = 10
// a的类型是int
// b = hello
// b的类型是string
```

#### 短声明（只能在函数内）

```go
package main

import "fmt"

func main() {
	c := "1"
	fmt.Printf("c = %s, c的类型是%T\n", c, c)
}
// c = 1, c的类型是string
```

#### 多变量声明

```go
package main

func main(){
    var xx, yy int = 100, 200
    var kk, wx = 300, "666
    var (
        nn int = 100
        mm bool = true
    )
}
```

### 常量

```go
package main

import "fmt"

func main(){
    // 常量(只读属性)
    const length int = 10
    // length = 100  // 常量是不允许被修改的
    fmt.Println("length = ", length)
}
```

#### 使用常量定义枚举类型

```go
package main

import "fmt"

// const来定义枚举类型
const (
    BEIJING = 0
    SHANGHAI = 1
    SHENZHEN = 2
)

func main() {
    fmt.Println("BEIJING = ", BEIJING)      // 0
    fmt.Println("SHANGHAI = ", SHANGHAI)    // 1
    fmt.Println("SHENZHEN = ", SHENZHEN)    // 2
}
```

#### iota常量计数器

`iota` 是一个常量生成器，用于生成一组相关的枚举值。`iota` 可以与 `const` 关键字一起使用，在定义一组枚举时，用来生成连续的值。const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)

```go
// iota 初始值为 0，每当出现一个新的常量声明时，它的值就会自动加 1，因此 Monday 的值为 1，Tuesday 的值为 2，以此类推。
const (
    Sunday = iota // 0
    Monday        // 1
    Tuesday       // 2
    Wednesday     // 3
    Thursday      // 4
    Friday        // 5
    Saturday      // 6
)

// 在下面的例子中，B 被显式赋值为 3.14，因此接下来的 C 的值为 iota + 1，即 2，而 D 的值也是 iota + 1，所以它的值为 3。
const (
    A = iota // 0
    B = 3.14 // 3.14
    C = iota // 2
    D        // 3
)
```

```go
package main

import "fmt"

// 定义递增的步长
const (
    BEIJING = iota * 10
    SHANGHAI
    SHENZHEN
)

func main() {
    fmt.Println("BEIJING = ", BEIJING)      // 0
    fmt.Println("SHANGHAI = ", SHANGHAI)    // 10
    fmt.Println("SHENZHEN = ", SHENZHEN)    // 20
}
```

## 基本数据类型

### 整型

- int8：有符号 8 位整数类型，取值范围为 -128 到 127。
- uint8（或 byte）：无符号 8 位整数类型，取值范围为 0 到 255。
- int16：有符号 16 位整数类型，取值范围为 -32768 到 32767。
- uint16：无符号 16 位整数类型，取值范围为 0 到 65535。
- int32（或 rune）：有符号 32 位整数类型，取值范围为 -2147483648 到 2147483647。
- uint32：无符号 32 位整数类型，取值范围为 0 到 4294967295。
- int64：有符号 64 位整数类型，取值范围为 -9223372036854775808 到 9223372036854775807。
- uint64：无符号 64 位整数类型，取值范围为 0 到 18446744073709551615。

```go
package main

import (
	"fmt"
	"math"
	"unsafe"
)

// 有符号整型
func Integer() {
	var num8 int8 = 127
	var num16 int16 = 32767
	var num32 int32 = math.MaxInt32
	var num64 int64 = math.MaxInt64
	var num int = math.MaxInt
	fmt.Printf("num8的类型是 %T, num8的大小 %d, num8是 %d\n",
		num8, unsafe.Sizeof(num8), num8)
	fmt.Printf("num16的类型是 %T, num16的大小 %d, num16是 %d\n",
		num16, unsafe.Sizeof(num16), num16)
	fmt.Printf("num32的类型是 %T, num32的大小 %d, num32是 %d\n",
		num32, unsafe.Sizeof(num32), num32)
	fmt.Printf("num64的类型是 %T, num64的大小 %d, num64是 %d\n",
		num64, unsafe.Sizeof(num64), num64)
	fmt.Printf("num的类型是 %T, num的大小 %d, num是 %d\n",
		num, unsafe.Sizeof(num), num)
}

// 无符号整型
func unsignedInteger() {
	var num8 uint8 = 128
	var num16 uint16 = 32768
	var num32 uint32 = math.MaxUint32
	var num64 uint64 = math.MaxUint64
	var num uint = math.MaxUint
	fmt.Printf("num8的类型是 %T, num8的大小 %d, num8是 %d\n",
		num8, unsafe.Sizeof(num8), num8)
	fmt.Printf("num16的类型是 %T, num16的大小 %d, num16是 %d\n",
		num16, unsafe.Sizeof(num16), num16)
	fmt.Printf("num32的类型是 %T, num32的大小 %d, num32是 %d\n",
		num32, unsafe.Sizeof(num32), num32)
	fmt.Printf("num64的类型是 %T, num64的大小 %d, num64是 %d\n",
		num64, unsafe.Sizeof(num64), num64)
	fmt.Printf("num的类型是 %T, num的大小 %d, num是 %d\n",
		num, unsafe.Sizeof(num), num)
}

func main() {
	Integer()
	println("---------------------------------------")
	unsignedInteger()
}
```

:::tip

- 除非对整型的大小有特定的需求，否则你通常应该使用 `int` 表示整型宽度，在 `32` 位系统下是 `32` 位，而在 `64` 位系统下是 `64` 位。表示范围：在 `32` 位系统下是 `-2147483648` ~ `2147483647` ，而在 `64` 位系统是 `-9223372036854775808` ~ `9223372036854775807` 。
- 对于 `int8` ， `int16` 等这些类型后面有跟一个数值的类型来说，它们能表示的数值个数是固定的。所以，在有的时候：例如在二进制传输、读写文件的结构描述(为了保持文件的结构不会受到不同编译目标平台字节长度的影响)等情况下，使用更加精确的 `int32` 和 `int64` 是更好的。

:::

### 浮点型

- `float32` 类型的变量占用 4 个字节的内存，可以表示的数值范围为±1.401298464324817e-45 到±3.4028234663852886e+38，精度约为 7 个十进制位。

- `float64` 类型的变量占用 8 个字节的内存， 可以表示的数值范围为±4.9406564584124654e-324 到±1.7976931348623157e+308，精度约为 15 个十进制位。

Go 语言中的浮点数默认为 `float64` 类型，如果需要使用 `float32` 类型，需要显式声明。

```go
package main

import (
	"fmt"
	"math"
)

func showFloat() {
	var num1 float32 = math.MaxFloat32
	var num2 float64 = math.MaxFloat64
	fmt.Printf("num1的类型是%T,num1是%g\n", num1, num1)
	fmt.Printf("num2的类型是%T,num1是%g\n", num2, num2)
}

func main() {
	showFloat()
}
//num1的类型是float32,num1是3.4028235e+38
//num2的类型是float64,num1是1.7976931348623157e+308
```

### 字符

字符串中的每一个元素叫作“字符”，定义字符时使用单引号。Go 语言的字符有两种。

- `byte`类型，占用1个字节，表示 UTF-8 字符串的单个字节的值，表示的是 ASCII 码表中的一个字符，uint8 的别名类型
- `rune`类型，占用4个字节，表示单个 unicode 字符，int32 的别名类型

```go
package main

import "fmt"

func showChar() {
     var x byte = 65
     var y uint8 = 65
     fmt.Printf("x = %c\n", x)   // x = A
     fmt.Printf("y = %c\n", y)   // y = A
}

func sizeOfChar() {
    var x byte = 65
    fmt.Printf("x = %c\n", x)
    fmt.Printf("x 占用 %d 个字节\n", unsafe.Sizeof(x))

    var y rune = 'A'
    fmt.Printf("y = %c\n", y)
    fmt.Printf("y 占用 %d 个字节\n", unsafe.Sizeof(y))
}

func main() {
    showChar();
    sizeOfChar();
}
```

### 字符串

字符串在Go语言中是基本数据类型。

```go
var study string  	 		// 定义名为str的字符串类型变量
study = "《123》"		// 将变量赋值
study2 := "《789》"		// 以自动推断方式初始化
```

定义多行字符串的方法如下。

- 双引号书写字符串被称为字符串字面量（string literal），这种字面量不能跨行。
- 多行字符串需要使用反引号“`”，多用于内嵌源码和内嵌数据。
- 在反引号中的所有代码不会被编译器识别，而只是作为字符串的一部分。

```go
package main
import "fmt"

func main() {
  var s1 string
	s1 = `
    		study := 'Go语言'
    		fmt.Println(study)
			`
	fmt.Println(s1)
}
```

### 布尔

```go
func showBool(){
	a := true
	b := false
	fmt.Println("a=", a)
	fmt.Println("b=", b)
	fmt.Println("true && false = ", a && b)
	fmt.Println("true || false = ", a || b)
}

func main() {
    showBool()
}
```

### 复数

| 类 型      | 字 节 数 | 说 明                                               |
| ---------- | -------- | --------------------------------------------------- |
| complex64  | 8        | 64 位的复数型，由 float32 类型的实部和虚部联合表示  |
| complex128 | 16       | 128 位的复数型，由 float64 类型的实部和虚部联合表示 |

```go
func showComplex() {
	// 内置的 complex 函数用于构建复数
	var x complex64 = complex(1, 2)
	var y complex128 = complex(3, 4)
	var z complex128 = complex(5, 6)
	fmt.Println("x = ", x)
	fmt.Println("y = ", y)
	fmt.Println("z = ", z)

	// 内建的 real 和 imag 函数分别返回复数的实部和虚部
	fmt.Println("real(x) = ", real(x))
	fmt.Println("imag(x) = ", imag(x))
	fmt.Println("y * z = ", y*z)
}

func main() {
   showComplex()
}
```

:::tip

同样可以用自然方式表示复数

```go
x := 1 + 2i
y := 3 + 4i
z := 5 + 6i
```

:::

### fmt格式化输出

| **格式** | **含义**                                                     |
| -------- | ------------------------------------------------------------ |
| %%       | 一个%字面量                                                  |
| %b       | 一个二进制整数值(基数为 2)，或者是一个(高级的)用科学计数法表示的指数为 2 的浮点数 |
| %c       | 字符型。可以把输入的数字按照 ASCII 码相应转换为对应的字符    |
| %d       | 一个十进制数值(基数为 10)                                    |
| %f       | 以标准记数法表示的浮点数或者复数值                           |
| %o       | 一个以八进制表示的数字(基数为 8)                             |
| %p       | 以十六进制(基数为 16)表示的一个值的地址，前缀为 0x,字母使用小写的 a-f 表示 |
| %q       | 使用 Go 语法以及必须时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字 |
| %s       | 字符串。输出字符串中的字符直至字符串中的空字符（字符串以’\0‘结尾，这个’\0’即空字符） |
| %t       | 以 true 或者 false 输出的布尔值                              |
| %T       | 使用 Go 语法输出的值的类型                                   |
| %x       | 以十六进制表示的整型值(基数为十六)，数字 a-f 使用小写表示    |
| %X       | 以十六进制表示的整型值(基数为十六)，数字 A-F 使用小写表示    |

## 容器类型

### 数组

Go 中的数组是值类型而不是引用类型。当数组赋值给一个新的变量时，该变量会得到一个原始数组的一个副本。如果对新变量进行更改，不会影响原始数组。

```go
func arrByValue() {
	arr := [...]string{"123", "456", "789"}
	copy := arr
	copy[0] = "Golang"
	fmt.Println(arr)
	fmt.Println(copy)
}
```

#### 声明

`var variable_name [SIZE]variable_type`

#### 初始化

- `var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}`
- `balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}`

如果数组长度不确定，可以使用 **...** 代替数组的长度，编译器会根据元素个数自行推断数组的长度：

```go
var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
或
balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
```

如果设置了数组的长度，我们还可以通过指定下标来初始化元素：

```go
//  将索引为 1 和 3 的元素初始化
balance := [5]float32{1:2.0,3:7.0}
```

初始化数组中 **{}** 中的元素个数不能大于 **[]** 中的数字。

如果忽略 **[]** 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：

```go
 balance[4] = 50.0
```

#### 访问

数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。例如：

```go
var salary float32 = balance[9]
```

#### 数组长度

`len(arr)`

#### 数组遍历

使用`for range循环`

```go
func showArr() {
	arr := [...]string{"123", "456", "789"}
	for index, value := range arr {
		fmt.Printf("arr[%d]=%s\n", index, value)
	}

	for _, value := range arr {
		fmt.Printf("value=%s\n", value)
	}
}
```

### 切片Slice

Go 语言切片是对数组的抽象。

Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片("动态数组")，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。

#### 定义切片

```go
var identifier []type
```

切片不需要说明长度。

或使用 **make()** 函数来创建切片:

```go
var slice1 []type = make([]type, len)

也可以简写为

slice1 := make([]type, len)
```

也可以指定容量，其中 **capacity** 为可选参数。

```go
make([]T, length, capacity)
```

这里 len 是数组的长度并且也是切片的初始长度。

#### 切片初始化

直接初始化切片，**[]** 表示是切片类型，**{1,2,3}** 初始化值依次是 **1,2,3**，其 **cap=len=3**。

```go
s :=[] int {1,2,3 } 
```

初始化切片 **s**，是数组 arr 的引用。

```go
s := arr[:] 
```

将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片。

```go
s := arr[startIndex:endIndex] 
```

默认 endIndex 时将表示一直到arr的最后一个元素。

```go
s := arr[startIndex:] 
```

默认 startIndex 时将表示从 arr 的第一个元素开始。

```go
s := arr[:endIndex] 
```

通过切片 s 初始化切片 s1。

```go
s1 := s[startIndex:endIndex] 
```

通过内置函数 **make()** 初始化切片**s**，**[]int** 标识为其元素类型为 int 的切片。

```go
s :=make([]int,len,cap) 
```

> `make([]T, length, capacity)` 用于创建一个指定类型 `T`、长度为 `length`、容量为 `capacity` 的切片。其中，`length` 表示切片的实际长度，而 `capacity` 则表示切片底层数组的容量。
>
> 切片的容量可以理解为底层数组能够容纳的元素数量。当切片的容量不足以容纳新添加的元素时，Go 会自动将底层数组扩展一倍，并将原有的元素复制到新的数组中。因此，在预先分配足够容量的情况下，可以避免频繁的内存分配和数据复制操作，提高代码的性能。
>
> 需要注意的是，`capacity` 参数不能小于 `length` 参数。如果 `capacity` 小于 `length`，则会抛出一个运行时异常。

- 由于 slice 是引用类型，所以你不对它进行赋值的话，它的默认值是 `nil`

```go
var numList []int
fmt.Println(numList == nil) // true
```

- 切片之间不能比较，因此我们不能使用 `==` 操作符来判断两个 slice 是否含有全部相等元素。特别注意，如果你需要测试一个 slice 是否是空的，使用 `len(s) == 0` 来判断，而不应该用 `s == nil` 来判断。

#### 切片的长度和容量

一个 slice 由三个部分构成：**指针** 、 **长度** 和 **容量** 。指针指向第一个 slice 元素对应的底层数组元素的地址，要注意的是 slice 的第一个元素并不一定就是数组的第一个元素。长度对应 slice 中元素的数目；长度不能超过容量，容量一般是从 slice 的开始位置到底层数据的结尾位置。简单的讲，容量就是从创建切片索引开始的底层数组中的元素个数，而长度是切片中的元素个数。

内置的 `len` 和 `cap` 函数分别返回 slice 的长度和容量。

```go
s := make([]string, 3, 5)
fmt.Println(len(s)) // 3
fmt.Println(cap(s)) // 5
```

#### 切片元素修改

切片自己不拥有任何数据。它只是底层数组的一种表示。对切片所做的任何修改都会反映在底层数组中。

```go
func modifySlice() {
	var arr = [...]string{"123", "456", "789"}
	s := arr[:] //[0:len(arr)]
	fmt.Println(arr) 
	fmt.Println(s)

	s[0] = "Go语言"
	fmt.Println(arr) 
	fmt.Println(s) 
}
```

这里的 `arr[:]` 没有填入起始值和结束值，默认就是 `0` 和 `len(arr)` 。

#### 追加切片元素

使用 `append` 可以将新元素追加到切片上。`append` 函数的定义是 `func append(slice []Type, elems ...Type) []Type` 。其中 `elems ...Type` 在函数定义中表示该函数接受参数 `elems` 的个数是可变的。这些类型的函数被称为可变参数。

```go
func appendSliceData() {
	s := []string{"123"}
	fmt.Println(s)
	fmt.Println(cap(s))

	s = append(s, "567")
	fmt.Println(s)
	fmt.Println(cap(s))

	s = append(s, "789", "0")
	fmt.Println(s)
	fmt.Println(cap(s))

	s = append(s, []string{"1", "2"}...)
	fmt.Println(s)
	fmt.Println(cap(s))
}
```

当新的元素被添加到切片时，如果容量不足，会创建一个新的数组。现有数组的元素被复制到这个新数组中，并返回新的引用。现在新切片的容量是旧切片的两倍。

#### 多维切片

类似于数组，切片也可以有多个维度。

```go
func mSlice() {
	numList := [][]string{
		{"1", "123"},
		{"2", "456"},
		{"3", "789"},
	}
	fmt.Println(numList)
}
```

### Map

在 Go 语言中，map 是散列表(哈希表)的引用。它是一个拥有键值对元素的**无序集合**，在这个集合中，键是唯一的，可以通过键来获取、更新或移除操作。无论这个散列表有多大，这些操作基本上是通过常量时间完成的。所有可比较的类型，如 `整型` ，`字符串` 等，都可以作为 `key` 。

#### 创建Map

使用 `make` 函数传入键和值的类型，可以创建 map 。具体语法为 `make(map[KeyType]ValueType)` 。

```go
// 创建一个键类型为 string 值类型为 int 名为 scores 的 map
scores := make(map[string]int)
steps := make(map[string]string)
```

字面量创建：

```go
var steps2 map[string]string = map[string]string{
		"第一步": "123",
		"第二步": "456",
		"第三步": "789",
}
fmt.Println(steps2)
```

```go
steps3 := map[string]string{
		"第一步": "123",
		"第二步": "456",
		"第三步": "789",
}
fmt.Println(steps3)
```

#### Map操作

- 添加元素

  ```GO
  // 可以使用 `map[key] = value` 向 map 添加元素。
  steps3["第四步"] = "总监"
  ```

- 更新元素

  ```GO
  // 若 key 已存在，使用 map[key] = value 可以直接更新对应 key 的 value 值。
  steps3["第四步"] = "CTO"
  ```

- 获取元素

  ```GO
  // 直接使用 map[key] 即可获取对应 key 的 value 值,如果 key不存在,会返回其 value 类型的零值。
  fmt.Println(steps3["第四步"] )
  ```

- 删除元素

  ```GO
  //使用 delete(map, key)可以删除 map 中的对应 key 键值对,如果 key 不存在,delete 函数会静默处理，不会报错。
  delete(steps3, "第四步")
  ```

- 判断 key 是否存在

  ```GO
  // 如果我们想知道 map 中的某个 key 是否存在，可以使用下面的语法：value, ok := map[key]
  v3, ok := steps3["第三步"]
  fmt.Println(ok)
  fmt.Println(v3)
  
  v4, ok := steps3["第四步"]
  fmt.Println(ok)
  fmt.Println(v4)
  ```

  这个语句说明 `map` 的下标读取可以返回两个值，第一个值为当前 `key` 的 `value` 值，第二个值表示对应的 `key` 是否存在，若存在 `ok` 为 `true` ，若不存在，则 `ok` 为 `false` 。

- 遍历 map

  ```GO
  // 遍历 map 中所有的元素需要用 for range 循环。
  for key, value := range steps3 {
      fmt.Printf("key: %s, value: %s\n", key, value)
  }
  ```

- 获取 map 长度

  ```GO
  // 使用 len 函数可以获取 map 长度
  func createMap() {
    	//...
       fmt.Println(len(steps3))    // 4
  }
  ```

#### map是引用类型

当 `map` 被赋值为一个新变量的时候，它们指向同一个内部数据结构。因此，改变其中一个变量，就会影响到另一变量。

```GO
func mapByReference() {
		steps4 := map[string]string{
		"第一步": "123",
		"第二步": "456",
		"第三步": "789",
	}
	fmt.Println("steps4: ", steps4)
	// steps4:  map[第一步:123 第三步:789 第二步:456]
	newSteps4 := steps4
	newSteps4["第一步"] = "123-222"
	newSteps4["第二步"] = "456-222"
	newSteps4["第三步"] = "789-222"
	fmt.Println("steps4: ", steps4)
  // steps4:  map[第一步:123-222 第三步:789-222 第二步:456-222]
	fmt.Println("newSteps4: ", newSteps4)
  // newSteps4:  map[第一步:123-222 第三步:789-222 第二步:456-222]
}
```

当 `map` 作为函数参数传递时也会发生同样的情况。

## 流程控制语句

### 条件语句

```go
if 条件1 {
  逻辑代码1
} else if  条件2 {
  逻辑代码2
} else if 条件 ... {
  逻辑代码 ...
} else {
  逻辑代码 else
}
```

```go
score := 88
if score >= 90 {
    fmt.Println("成绩等级为A")
} else if score >= 80 {
    fmt.Println("成绩等级为B")
} else if score >= 70 {
    fmt.Println("成绩等级为C")
} else if score >= 60 {
    fmt.Println("成绩等级为D")
} else {
    fmt.Println("成绩等级为E 成绩不及格")
}
```

`if` 还有另外一种写法，它包含一个 `statement` 可选语句部分，该可选语句在条件判断之前运行。它的语法是：

```go
if statement; condition {
}

if score := 88; score >= 60 {
    fmt.Println("成绩及格")
}
```

### switch case

```go
switch 表达式 {
    case 表达式值1:
        业务逻辑代码1
    case 表达式值2:
        业务逻辑代码2
    case 表达式值3:
        业务逻辑代码3
    case 表达式值 ...:
        业务逻辑代码 ...
    default:
        业务逻辑代码
}
```

```go
grade := "B"
switch grade {
case "A":
    fmt.Println("Your score is between 90 and 100.")
case "B":
    fmt.Println("Your score is between 80 and 90.")
case "C":
    fmt.Println("Your score is between 70 and 80.")
case "D":
    fmt.Println("Your score is between 60 and 70.")
default:
    fmt.Println("Your score is below 60.")
}
```

**一个 case 多个条件**

```go
month := 5
switch month {
case 1, 3, 5, 7, 8, 10, 12:
    fmt.Println("该月份有 31 天")
case 4, 6, 9, 11:
    fmt.Println("该月份有 30 天")
case 2:
    fmt.Println("该月份闰年为 29 天，非闰年为 28 天")
default:
    fmt.Println("输入有误！")
}
```

`switch` 还有另外一种写法，它包含一个 `statement` 可选语句部分，该可选语句在表达式之前运行。它的语法是：

```go
switch statement; expression {
}


switch month := 5; month {
case 1, 3, 5, 7, 8, 10, 12:
    fmt.Println("该月份有 31 天")
case 4, 6, 9, 11:
    fmt.Println("该月份有 30 天")
case 2:
    fmt.Println("该月份闰年为 29 天，非闰年为 28 天")
default:
    fmt.Println("输入有误！")
}
```

 这里 `month` 变量的作用域就仅限于这个 `switch` 内。

**switch 后可接函数**

`switch` 后面可以接一个函数，只要保证 `case` 后的值类型与函数的返回值一致即可。

```go
package main

import "fmt"

func getResult(args ...int) bool {
 for _, v := range args {
  if v < 60 {
   return false
  }
 }
 return true
}

func main() {
 chinese := 88
 math := 90
 english := 95

 switch getResult(chinese, math, english) {
 case true:
  fmt.Println("考试通过")
 case false:
  fmt.Println("考试未通过")
 }
}
```

**无表达式的 switch**

`switch` 后面的表达式是可选的。如果省略该表达式，则表示这个 `switch` 语句等同于 `switch true` ，并且每个 `case` 表达式都被认定为有效，相应的代码块也会被执行。

```go
score := 88
switch {
case score >= 90 && score <= 100:
    fmt.Println("grade A")
case score >= 80 && score < 90:
    fmt.Println("grade B")
case score >= 70 && score < 80:
    fmt.Println("grade C")
case score >= 60 && score < 70:
    fmt.Println("grade D")
case score < 60:
    fmt.Println("grade E")
}
```

该 `switch-case` 语句相当于 `if-elseif-else` 语句。

**fallthrough 语句**

正常情况下 `switch-case` 语句在执行时只要有一个 `case` 满足条件，就会直接退出 `switch-case` ，如果一个都没有满足，才会执行 `default` 的代码块。不同于其他语言需要在每个 `case` 中添加 `break` 语句才能退出。使用 `fallthrough` 语句可以在已经执行完成的 `case` 之后，把控制权转移到下一个 `case` 的执行代码中。`fallthrough` 只能穿透一层，不管你有没有匹配上，都要退出了。`fallthrough` 语句是 `case` 子句的最后一个语句。如果它出现在了 `case` 语句的中间，编译会不通过。

```go
s := "123"
switch {
case s == "123":
    fmt.Println("123")
    fallthrough
case s == "456":
    fmt.Println("456")
case s != "789":
    fmt.Println("789")
}
```

### 循环语句

**循环语句** 可以用来重复执行某一段代码。在 C 语言中，循环语句有 `for` 、 `while` 和 `do while` 三种循环。但在 Go 中只有 `for` 一种循环语句。下面是 `for` 循环语句的四种基本模型：

```go
// for 接三个表达式
for initialisation; condition; post {
   code
}

// for 接一个条件表达式
for condition {
   code
}

// for 接一个 range 表达式
for range_expression {
   code
}

// for 不接表达式
for {
   code
}
```

- **接一个条件表达式**

  ```go
  num := 0
  for num < 4 {
      fmt.Println(num)
      num++
  }
  ```

- **接三个表达式**

  `for` 后面接的这三个表达式，各有各的用途：

  - 第一个表达式(`initialisation`)：初始化控制变量，在整个循环生命周期内，只执行一次；
  - 第二个表达式(`condition`)：设置循环控制条件，该表达式值为 `true` 时循环，值为 `false` 时结束循环；
  - 第三个表达式(`post`)：每次循环完都会执行此表达式，可以利用其让控制变量增量或减量。

  这三个表达式，使用 `;` 分隔。

  ```go
  for num := 0; num < 4; num++ {
      fmt.Println(num)
  }
  ```

- **接一个 range 表达式**

  ```go
  str := "Golang"
  for index, value := range str{
      fmt.Printf("index %d, value %c\n", index, value)
  }
  ```

- **不接表达式**	

  `for` 后面不接表达式就相当于无限循环，当然，可以使用 `break` 语句退出循环

  ```go
  // 第一种写法
  for {
      code
  }
  // 第二种写法
  for ;; {
      code
  }
  ```

- **break 语句**

  `break` 语句用于终止 `for` 循环，之后程序将执行在 `for` 循环后的代码。上面的例子已经演示了 `break` 语句的使用。

- **continue 语句**

  `continue` 语句用来跳出 `for` 循环中的当前循环。在 `continue` 语句后的所有的 `for` 循环语句都不会在本次循环中执行，执行完 `continue` 语句后将会继续执行一下次循环。下面的程序会打印出 `10` 以内的奇数。

### defer延迟调用

含有 `defer` 语句的函数，会在该函数将要返回之前，调用另一个函数。简单点说就是 `defer` 语句后面跟着的函数会延迟到当前函数执行完后再执行。

```go
package main

import "fmt"

func bookPrint() {
	fmt.Println("123")
}

func main() {
	defer bookPrint()
	fmt.Println("main函数...")
}
```

首先，执行 `main` 函数，因为 `bookPrint()` 函数前有 `defer` 关键字，所以会在执行完 `main` 函数后再执行 `bookPrint()` 函数，所以先打印出 `main函数...` ，再执行 `bookPrint()` 函数打印 `123` 。



**即时求值的变量快照**

使用 `defer` 只是延时调用函数，传递给函数里的变量，不应该受到后续程序的影响。

```go
str := "123"
defer fmt.Println(str)
str = "456"
fmt.Println(str)
// 456
// 123
```

**延迟方法**

`defer` 不仅能够延迟函数的执行，也能延迟方法的执行。

```go
package main

import "fmt"

type Book struct {
	bookName, authorName string
}

func (b Book) printName() {
	fmt.Printf("%s %s", b.bookName, b.authorName)
}

func main() {
	book := Book{"123", "456"}
	defer book.printName()
	fmt.Printf("main... ")
}
// main... 123 456
```

**defer 栈**

当一个函数内多次调用 `defer` 时，Go 会把 `defer` 调用放入到一个栈中，随后按照 **后进先出** 的顺序执行。

```go
package main

import "fmt"

func main() {
	defer fmt.Printf("123")
	defer fmt.Printf("456")
	defer fmt.Printf("789")
	fmt.Printf("main...")
}
//main...789456123
```

**defer 在 return 后调用**

```go
package main

import "fmt"

var s string = "123"

func showLesson() string {
    defer func() {
        s = "456"
    }()
    fmt.Println("showLesson: s =", s)
    return s
}

func main() {
    lesson := showLesson()
    fmt.Println("main: s =", s)
    fmt.Println("main: lesson =", lesson)
}
//showLesson: s = 123
//main: s = 456
//main: lesson = 123
```

> ### Go 中 defer 和 return 执行的先后顺序
>
> 1. 多个defer的执行顺序为“后进先出”；
> 2. defer、return、返回值三者的执行逻辑应该是：return最先执行，return负责将结果写入返回值中；接着defer开始执行一些收尾工作；最后函数携带当前返回值退出。
>
> 如果函数的返回值是无名的（不带命名返回值），则go语言会在执行return的时候会执行一个类似创建一个临时变量作为保存return值的动作，而有名返回值的函数，由于返回值在函数定义的时候已经将该变量进行定义，在执行return的时候会先执行返回值保存操作，而后续的defer函数会改变这个返回值(虽然defer是在return之后执行的，但是由于使用的函数定义的变量，所以执行defer操作后对该变量的修改会影响到return的值

**defer 可以使代码更简洁**

如果没有使用 `defer` ，当在一个操作资源的函数里调用多个 `return` 时，每次都得释放资源，你可能这样写代码：

```go
func f() {
    r := getResource()  //0，获取资源
    ......
    if ... {
        r.release()  //1，释放资源
        return
    }
    ......
    if ... {
        r.release()  //2，释放资源
        return
    }
    ......
    if ... {
        r.release()  //3，释放资源
        return
    }
    ......
    r.release()     //4，释放资源
    return
}
```

有了 `defer` 之后，可以简洁地写成下面这样：

```go
func f() {
    r := getResource()  //0，获取资源

    defer r.release()  //1，释放资源
    ......
    if ... {
        ...
        return
    }
    ......
    if ... {
        ...
        return
    }
    ......
    if ... {
        ...
        return
    }
    ......
    return
}
```

### goto无条件跳转

在 Go 语言中保留 `goto` 。`goto` 后面接的是标签，表示下一步要执行哪里的代码。

```go
package main

import "fmt"

func main() {
	fmt.Println("123")
	goto label
	fmt.Println("456")
label:
    fmt.Println("789")
}
//123
//789
```

## 指针

一个指针变量指向了一个值的内存地址。

类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：

```go
var var_name *var-type
```

var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。以下是有效的指针声明：

```go
var ip *int        /* 指向整型*/
var fp *float32    /* 指向浮点型 */
```

### 操作符

- & 操作符可以从一个变量中取到其内存地址。

* 操作符如果在赋值操作值的左边，指该指针指向的变量；* 操作符如果在赋值操作符的右边，指从一个指针变量中取得变量值，又称指针的解引用。

### 如何使用指针

指针使用流程：

- 定义指针变量。
- 为指针变量赋值。
- 访问指针变量中指向地址的值。
- 在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。

```go
package main

import "fmt"

func main() {
   var a int= 20   /* 声明实际变量 */
   var ip *int        /* 声明指针变量 */

   ip = &a  /* 指针变量的存储地址 */

   fmt.Printf("a 变量的地址是: %x\n", &a  )

   /* 指针变量的存储地址 */
   fmt.Printf("ip 变量储存的指针地址: %x\n", ip )

   /* 使用指针访问值 */
   fmt.Printf("*ip 变量的值: %d\n", *ip )
}
//a 变量的地址是: 20818a220
//ip 变量储存的指针地址: 20818a220
//*ip 变量的值: 20
```

### 空指针

当一个指针被定义后没有分配到任何变量时，它的值为 nil。

nil 指针也称为空指针。

nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。

一个指针变量通常缩写为 ptr。

```go
package main

import "fmt"

func main() {
  var ptr *int

  fmt.Printf("ptr 的值为 : %x**\n**", ptr  )
}
//ptr 的值为 : 0
```

空指针判断

```go
if(ptr != nil)     /* ptr 不是空指针 */
if(ptr == nil)    /* ptr 是空指针 */
```

### 函数传递指针函数

在函数中对指针参数所做的修改，在函数返回后会保存相应的修改。

```go
package main

import (
	"fmt"
)

func changeByPointer(value *int) {
	*value = 200
}

func main() {
	x3 := 99
	p3 := &x3
	fmt.Println("执行changeByPointer函数之前p3是", *p3)
	changeByPointer(p3)
	fmt.Println("执行changeByPointer函数之后p3是", *p3)
}
//执行changeByPointer函数之前p3是 99
//执行changeByPointer函数之后p3是 200

```

### 指针与切片

切片与指针一样是引用类型，如果我们想通过一个函数改变一个数组的值，可以将该数组的切片当作参数传给函数，也可以将这个数组的指针当作参数传给函数。但 Go 中建议使用第一种方法，即将该数组的切片当作参数传给函数，因为这么写更加简洁易读。

```go
package main

import "fmt"

// 使用切片
func changeSlice(value []int) {
	value[0] = 200
}

// 使用数组指针
func changeArray(value *[3]int) {
	(*value)[0] = 200
}

func main() {
	x := [3]int{10, 20, 30}
	changeSlice(x[:])
	fmt.Println(x) // [200 20 30]

	y := [3]int{100, 200, 300}
	changeArray(&y)
	fmt.Println(y) // [200 200 300]
}
```

## 结构体

Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。

结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。Go中没有`class`的概念，只有`struct`结构体，所以也没有继承。

### 声明

```go
type struct_name struct {
    attribute_name1   attribute_type
    attribute_name2   attribute_type
    ...
}

type Lesson struct {
	name   string //名称
	target string //学习目标
	spend  int    //学习花费时间
}
//可以把相同类型的属性声明在同一行，这样可以使结构体变得更加紧凑
type Lesson2 struct {
    name, target    string
    spend             int
}
```

上面的结构体称为命名结构体`Named Structure`。声明结构体时也可以不用声明新类型，这种结构体类型称为匿名结构体`Anonymous Structure`

```go
var Lesson3 struct {
    name, target    string
    spend             int
}
```

### 创建命名结构体

```go
package main

import "fmt"

type Lesson struct {
	name, target    string
	spend             int
}

func main() {
	// 使用字段名创建结构体
	lesson1 := Lesson{
		name: "Golang",
		target: "学习Go语言，并完成一个单体服务",
		spend:  5,
	}
	// 不使用字段名创建结构体，按字段声明顺序初始化
	lesson2 := Lesson{"Golang", "学习Go语言，并完成一个单体服务", 5}

	fmt.Println("lesson1 ", lesson1)
	fmt.Println("lesson2 ", lesson2)
}
```

### 创建匿名结构体

```go
package main

import "fmt"

func main() {
	// 创建匿名结构体变量
	lesson3 := struct {
		name, target string
		spend          int
	}{
		name:   "Go语言",
		target: "掌握GO语言",
		spend:   3,
	}

	fmt.Println("lesson3 ", lesson3)
}
```

### 结构体的零值(Zero Value)

当定义好的结构体没有被显式初始化时，结构体的字段将会默认赋为相应类型的零值。

```go
package main

import "fmt"

type Lesson struct {
	name, target    string
	spend             int
}

func main() {
	// 不初始化结构体
	var lesson4 = Lesson{}

	fmt.Println("lesson4 ", lesson4)
}
//lesson4  {  0}
```

### 访问结构体字段

使用`.`点操作符访问：`lesson.name`

使用`.`也可用与给结构体字段赋值:`lesson.name = "test"`

### 指向结构体的指针

```go
package main

import "fmt"

type Lesson struct {
	name, target    string
	spend             int
}

func main() {
	lesson8 := &Lesson{"Go语言", "Go语言微服务", 50}
	fmt.Println("lesson8 name: ", (*lesson8).name)
	fmt.Println("lesson8 name: ", lesson8.name)
}
```

 `lesson8` 是一个指向结构体 `Lesson` 的指针，用 `(*lesson8).name` 访问 `lesson8` 的 `name` 字段， `lesson8.name` 代替 `(*lesson8).name` 的解引用访问。

### 匿名字段

在创建结构体时，字段可以只有类型没有字段名，这种字段称为 **匿名字段(Anonymous Field)** 。

```go
package main

import "fmt"

type Lesson4 struct {
	string
	int
}

func main() {
	lesson9 := Lesson4{"Golang", 50}
	fmt.Println("lesson9 ", lesson9)
	fmt.Println("lesson9 string: ", lesson9.string)
	fmt.Println("lesson9 int: ", lesson9.int)
}
```

上面的程序结构体定义了两个匿名字段，虽然这两个字段没有字段名，但匿名字段的名称默认就是它的类型。所以上面的结构体 `Lesoon4` 有两个名为 `string` 和 `int` 的字段。

### 嵌套结构体

结构体的字段也可能是另外一个结构体，这样的结构体称为 **嵌套结构体(Nested Structs)**

```go
package main

import "fmt"

type Author struct {
	name string
  	wx string
}

type Lesson5 struct {
	name,target string
	spend int
	author Author
}

func main() {
	lesson10 := Lesson5{
		name: "Go语言",
		spend: 50,
	}
	lesson10.author = Author{
		name: "golang",
		wx: "666",
	}
	fmt.Println("lesson10 name:", lesson10.name)
	fmt.Println("lesson10 spend:", lesson10.spend)
	fmt.Println("lesson10 author name:", lesson10.author.name)
	fmt.Println("lesson10 author wx:", lesson10.author.wx)
}
```

上面的程序 `Lesson5` 结构体有一个字段 `author` ，而且它的类型也是一个结构体 `Author` 。

### 提升字段

结构体中如果有匿名的结构体类型字段，则该匿名结构体里的字段就称为 **提升字段(Promoted Fields)** 。这是因为提升字段就像是属于外部结构体一样，可以用外部结构体直接访问。就像刚刚上面的程序，如果我们把 `Lesson` 结构体中的字段 `author` 直接用匿名字段 `Author` 代替， `Author` 结构体的字段例如 `name` 就不用像上面那样使用 `lesson10.author.wx` 访问，而是使用 `lesson10.wx` 就能访问 `Author` 结构体中的 `wx` 字段。现在结构体 `Author` 有 `name` 、 `wx` 两个字段，访问字段就像在 `Lesson` 里直接声明的一样，因此我们称之为提升字段。

```go
package main

import "fmt"

type Author struct {
	name string
  	wx string
}

type Lesson6 struct {
	name,target string
	spend int
	Author
}

func main() {
	lesson10 := Lesson6{
		name:   "Go语言",
		target: "掌握Go语言",
	}
	lesson10.Author = Author{
		name: "golang",
		wx:   "666",
	}
	fmt.Println("lesson10 name:", lesson10.name)
	fmt.Println("lesson10 target:", lesson10.target)
	fmt.Println("lesson10 author wx:", lesson10.wx)
}
//lesson10 name: Go语言
//lesson10 target: 掌握Go语言
//lesson10 author wx: 666
```

### 结构体比较

如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用 `==` 或 `!=` 运算符进行比较。可以通过==运算符或 DeeplyEqual()函数比较两个结构相同的类型并包含相同的字段值。因此下面两个比较的表达式是等价的：

```go
package main

import "fmt"

type  Lesson  struct{
	name,target string
	spend int
}

func main() {
	lesson11 := Lesson{
		name:   "Go语言",
		target: "掌握Go语言",
	}
	lesson12 := Lesson{
		name:   "Go语言",
		target: "掌握Go语言",
	}
	fmt.Println(lesson11.name == lesson12.name && lesson11.target == lesson12.target) // true
	fmt.Println(lesson11 == lesson12) // true
}
```

### 给结构体定义方法

在 Go 中无法在结构体内部定义方法

```go
package main

import "fmt"

// Lesson 定义一个名为 Lesson 的结构体
type Lesson struct {
	name, target string
	spend        int
}

// ShowLessonInfo 定义一个与 Lesson 的绑定的方法
func (l Lesson) ShowLessonInfo() {
	fmt.Println("name:", l.name)
	fmt.Println("target:", l.target)
}

func main() {
	lesson13 := Lesson{
		name:   "Go语言",
		target: "掌握Go语言",
	}
	lesson13.ShowLessonInfo()
}
```

上面的程序中定义了一个与结构体 `Lesson` 绑定的方法 `ShowLessonInfo()` ，其中 `ShowLessonInfo` 是方法名， `(l Lesson)` 表示将此方法与 `Lesson` 的实例绑定，这在 Go 语言中称为接收者，而 `l` 表示实例本身，相当于 Python 中的 `self` ，在方法内可以使用 `实例本身.属性名称` 来访问实例属性。

### 方法的参数传递方式

如果绑定结构体的方法中要改变实例的属性时，必须使用指针作为方法的接收者。

```go
package main

import "fmt"

// Lesson 定义一个名为 Lesson 的结构体
type Lesson struct {
	name,target string
	spend int
}

// ShowLessonInfo 定义一个与 Lesson 的绑定的方法
func (l Lesson) ShowLessonInfo() {
	fmt.Println("name:", l.name)
	fmt.Println("target:", l.target)
}

// AddTime 定义一个与 Lesson 的绑定的方法，使 spend 值加 n
func (l *Lesson) AddTime(n int) {
	l.spend = l.spend + n
}

func main() {
	lesson13 := Lesson{
		name:   "Go语言",
		target: "掌握Go语言",
        spend:50,
	}
	fmt.Println("添加add方法前")
	lesson13.ShowLessonInfo()
	lesson13.AddTime(5)
	fmt.Println("添加add方法后")
	lesson13.ShowLessonInfo()
}
```

## 函数

**函数** 是基于功能或逻辑进行封装的可复用的代码结构。将一段功能复杂、很长的一段代码封装成多个代码片段(即函数)，有助于提高代码可读性和可维护性。由于 Go 语言是编译型语言，所以函数编写的顺序是无关紧要的。

### 声明

```go
func function_name(parameter_list) (result_list) {
    //函数体
}
```

### 可变参数

#### 多个类型一致的参数

在参数类型前面加 `...` 表示一个切片，用来接收调用者传入的参数。注意，如果该函数下有其他类型的参数，这些其他参数必须放在参数列表的前面，切片必须放在最后。

```go
package main

import "fmt"

func show(args ...string) int {
	sum := 0
	for _, item := range args {
        fmt.Println(item)
		sum += 1
	}
	return sum
}

func main() {
	fmt.Println(show("1","2","3"))
}
```

#### 多个类型不一致的参数

如果传多个参数的类型都不一样，可以指定类型为 `...interface{}` ，然后再遍历。

```go
package main

import "fmt"

func PrintType(args ...interface{}) {
	for _, arg := range args {
		switch arg.(type) {
		case int:
			fmt.Println(arg, "type is int.")
		case string:
			fmt.Println(arg, "type is string.")
		case float64:
			fmt.Println(arg, "type is float64.")
		default:
			fmt.Println(arg, "is an unknown type.")
		}
	}
}

func main() {
	PrintType(57, 3.14, "123")
}
```

### 解序列

使用 `...` 可以用来解序列

### 函数的返回值

当函数没有返回值时，函数体可以使用 `return` 语句返回。在 Go 中一个函数可以返回多个值。

```go
package main

import "fmt"

func showBookInfo(bookName, authorName string) (string, error) {
	if bookName == "" {
		return "", errors.New("图书名称为空")
	}
	if authorName == "" {
		return "", errors.New("作者名称为空")
	}
	return bookName + ",作者:" + authorName, nil
}

func main() {
	bookInfo, err := showBookInfo("123", "45")
	fmt.Printf("bookInfo = %s, err = %v", bookInfo, err)
}
```

返回带有变量名的值

```go
func showBookInfo2(bookName, authorName string) (info string, err error) {
	info = ""
	if bookName == "" {
		err = errors.New("图书名称为空")
		return
	}
	if authorName == "" {
		err = errors.New("作者名称为空")
		return
	}
    // 不使用 := 因为已经在返回值那里声明了
	info = bookName + ",作者:" + authorName
  	// 直接返回即可
	return
}
```

### 匿名函数

```go
func (parameter_list) (result_list) {
	body
}
```

### 内部方法与外部方法

在 Go 语言中，函数名通过首字母大小写实现控制对方法的访问权限。

- 当方法的首字母为 **大写** 时，这个方法对于 **所有包** 都是 **Public** ，其他包可以随意调用。
- 当方法的首字母为 **小写** 时，这个方法是 **Private** ，其他包是无法访问的。

## 包

**包(package)** 用于组织 Go 源代码，提供了更好的可重用性与可读性.可以用 `go list std`命令查看标准包,标准库为大多数的程序提供了必要的基础组件。

### 创建包

先创建一个 `book` 文件夹，位于该目录下创建一个 `book.go` 源文件，里面实现自定义的数学加法函数。函数名的首字母要大写。

```go
// Package book
package book

func ShowBookInfo(bookName, authorName string) (string, error) {
  if bookName == "" {
    return "", errors.New("图书名称为空")
  }
  if authorName == "" {
    return "", errors.New("作者名称为空")
  }
  return bookName + ",作者:" + authorName, nil
}
```

### 导入包

使用包之前我们需要导入包，在 GoLand 中会帮你自动导入所需要的包。导入包的语法为 `import path` ，其中 `path` 可以是相对于工作区文件夹的相对路径，也可以是绝对路径。

```go
package main

import (
	"fmt"
	"learn/book"
)

func main() {
	bookName := "《Go语言》"
	author := "Golang"
	bookInfo, _ := book.ShowBookInfo(bookName, author)
	fmt.Println("bookInfo = ", bookInfo)
}

```

### 使用别名

```go
import (
    "crypto/rand"
    mrand "math/rand" // 将名称替换为 mrand 避免冲突
)
```

### 使用点操作

```go
import . "fmt"

func main() {
    Println("hello, world")
}
```

对于一些使用高频的包，例如 `fmt` 包，每次调用打印函数时都要使用 `fmt.Println()` 进行调用，很不方便。可以在导入包的时，使用 `import . package_path` 语法。打印就不用加 `fmt` 了。

### 包的初始化

每个包都允许有一个或多个 `init` 函数， `init` 函数不应该有任何返回值类型和参数，在代码中也不能显式调用它，当这个包被导入时，就会执行这个包的 `init` 函数，做初始化任务， `init` 函数优先于 `main` 函数执行。该函数形式如下：

```go
func init() {
}
```

包的初始化顺序：首先初始化 **包级别(Package Level)** 的变量，紧接着调用 `init` 函数。包可以有多个 `init` 函数(在一个文件或分布于多个文件中)，它们按照编译器解析它们的顺序进行调用。如果一个包导入了另一个包，会先初始化被导入的包。尽管一个包可能会被导入多次，但是它只会被初始化一次。

### 包的匿名导入

导入一个没有使用的包编译会报错。但有时候我们只是想执行包里的 `init` 函数来执行一些初始化任务，可以使用匿名导入的方法，使用 **空白标识符(Blank Identifier)** ：

```go
import _ "fmt"
```
