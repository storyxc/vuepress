---
title: golang基础语法
date: 2023-06-25 22:24:49
permalink: /pages/2c6d76/
categories:
  - go
  - Golang基础
tags:
  - 
---
# Golang基础语法

## 第一个Go程序

```go
package main

import "fmt"

func main() {
	fmt.Println("Hello, World!")
}
```

## 关键字

- `package`：定义当前源码文件所属的包。
- `import`：导入其他包。
- `func`：定义函数。
- `var`：声明变量。
- `const`：声明常量。
- `type`：定义类型。
- `struct`：定义结构体。
- `interface`：定义接口。
- `map`：定义映射类型。
- `range`：用于循环迭代。
- `select`：用于通道操作。
- `defer`：延迟执行。
- `go`：启动一个新的 goroutine。
- `chan`：定义通道类型。
- `default`：select 语句中的默认情况。
- `fallthrough`：在 switch 语句中贯穿到下一个 case。
- `if`：条件语句。
- `else`：if 语句中的默认情况。
- `switch`：多分支条件语句。
- `case`：switch 语句中的分支情况。
- `for`：循环语句。
- `break`：跳出循环或 switch 语句。
- `continue`：结束当前循环，开始下一次循环。
- `return`：返回函数结果。
- `panic`：抛出异常。

## 变量与常量

### 变量

#### 声明变量不赋值

```go
package main

import "fmt"

func main() {
	var a int
	fmt.Println("a = ", a)
	fmt.Printf("a的类型是%T\n", a)
}
// a = 0
// a的类型是int
```

#### 声明变量并初始化

```go
package main

import "fmt"

func main() {
	var a int = 10
	fmt.Println("a =", a)
	fmt.Printf("a的类型是%T\n", a)

	var b string = "hello"
	fmt.Println("b =", b)
	fmt.Printf("b的类型是%T\n", b)
}
// a = 10
// a的类型是int
// b = hello
// b的类型是string
```

#### 声明变量省略类型

```go
package main

import "fmt"

func main() {
	var a = 10
	fmt.Println("a =", a)
	fmt.Printf("a的类型是%T\n", a)

	var b = "hello"
	fmt.Println("b =", b)
	fmt.Printf("b的类型是%T\n", b)
}
// a = 10
// a的类型是int
// b = hello
// b的类型是string
```

#### 短声明（只能在函数内）

```go
package main

import "fmt"

func main() {
	c := "1"
	fmt.Printf("c = %s, c的类型是%T\n", c, c)
}
// c = 1, c的类型是string
```

#### 多变量声明

```go
package main

func main(){
    var xx, yy int = 100, 200
    var kk, wx = 300, "666
    var (
        nn int = 100
        mm bool = true
    )
}
```

### 常量

```go
package main

import "fmt"

func main(){
    // 常量(只读属性)
    const length int = 10
    // length = 100  // 常量是不允许被修改的
    fmt.Println("length = ", length)
}
```

#### 使用常量定义枚举类型

```go
package main

import "fmt"

// const来定义枚举类型
const (
    BEIJING = 0
    SHANGHAI = 1
    SHENZHEN = 2
)

func main() {
    fmt.Println("BEIJING = ", BEIJING)      // 0
    fmt.Println("SHANGHAI = ", SHANGHAI)    // 1
    fmt.Println("SHENZHEN = ", SHENZHEN)    // 2
}
```

#### iota常量计数器

`iota` 是一个常量生成器，用于生成一组相关的枚举值。`iota` 可以与 `const` 关键字一起使用，在定义一组枚举时，用来生成连续的值。const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)

```go
// iota 初始值为 0，每当出现一个新的常量声明时，它的值就会自动加 1，因此 Monday 的值为 1，Tuesday 的值为 2，以此类推。
const (
    Sunday = iota // 0
    Monday        // 1
    Tuesday       // 2
    Wednesday     // 3
    Thursday      // 4
    Friday        // 5
    Saturday      // 6
)

// 在下面的例子中，B 被显式赋值为 3.14，因此接下来的 C 的值为 iota + 1，即 2，而 D 的值也是 iota + 1，所以它的值为 3。
const (
    A = iota // 0
    B = 3.14 // 3.14
    C = iota // 2
    D        // 3
)
```

```go
package main

import "fmt"

// 定义递增的步长
const (
    BEIJING = iota * 10
    SHANGHAI
    SHENZHEN
)

func main() {
    fmt.Println("BEIJING = ", BEIJING)      // 0
    fmt.Println("SHANGHAI = ", SHANGHAI)    // 10
    fmt.Println("SHENZHEN = ", SHENZHEN)    // 20
}
```

## 基本数据类型

### 整型

- int8：有符号 8 位整数类型，取值范围为 -128 到 127。
- uint8（或 byte）：无符号 8 位整数类型，取值范围为 0 到 255。
- int16：有符号 16 位整数类型，取值范围为 -32768 到 32767。
- uint16：无符号 16 位整数类型，取值范围为 0 到 65535。
- int32（或 rune）：有符号 32 位整数类型，取值范围为 -2147483648 到 2147483647。
- uint32：无符号 32 位整数类型，取值范围为 0 到 4294967295。
- int64：有符号 64 位整数类型，取值范围为 -9223372036854775808 到 9223372036854775807。
- uint64：无符号 64 位整数类型，取值范围为 0 到 18446744073709551615。

```go
package main

import (
	"fmt"
	"math"
	"unsafe"
)

// 有符号整型
func Integer() {
	var num8 int8 = 127
	var num16 int16 = 32767
	var num32 int32 = math.MaxInt32
	var num64 int64 = math.MaxInt64
	var num int = math.MaxInt
	fmt.Printf("num8的类型是 %T, num8的大小 %d, num8是 %d\n",
		num8, unsafe.Sizeof(num8), num8)
	fmt.Printf("num16的类型是 %T, num16的大小 %d, num16是 %d\n",
		num16, unsafe.Sizeof(num16), num16)
	fmt.Printf("num32的类型是 %T, num32的大小 %d, num32是 %d\n",
		num32, unsafe.Sizeof(num32), num32)
	fmt.Printf("num64的类型是 %T, num64的大小 %d, num64是 %d\n",
		num64, unsafe.Sizeof(num64), num64)
	fmt.Printf("num的类型是 %T, num的大小 %d, num是 %d\n",
		num, unsafe.Sizeof(num), num)
}

// 无符号整型
func unsignedInteger() {
	var num8 uint8 = 128
	var num16 uint16 = 32768
	var num32 uint32 = math.MaxUint32
	var num64 uint64 = math.MaxUint64
	var num uint = math.MaxUint
	fmt.Printf("num8的类型是 %T, num8的大小 %d, num8是 %d\n",
		num8, unsafe.Sizeof(num8), num8)
	fmt.Printf("num16的类型是 %T, num16的大小 %d, num16是 %d\n",
		num16, unsafe.Sizeof(num16), num16)
	fmt.Printf("num32的类型是 %T, num32的大小 %d, num32是 %d\n",
		num32, unsafe.Sizeof(num32), num32)
	fmt.Printf("num64的类型是 %T, num64的大小 %d, num64是 %d\n",
		num64, unsafe.Sizeof(num64), num64)
	fmt.Printf("num的类型是 %T, num的大小 %d, num是 %d\n",
		num, unsafe.Sizeof(num), num)
}

func main() {
	Integer()
	println("---------------------------------------")
	unsignedInteger()
}
```

:::tip

- 除非对整型的大小有特定的需求，否则你通常应该使用 `int` 表示整型宽度，在 `32` 位系统下是 `32` 位，而在 `64` 位系统下是 `64` 位。表示范围：在 `32` 位系统下是 `-2147483648` ~ `2147483647` ，而在 `64` 位系统是 `-9223372036854775808` ~ `9223372036854775807` 。
- 对于 `int8` ， `int16` 等这些类型后面有跟一个数值的类型来说，它们能表示的数值个数是固定的。所以，在有的时候：例如在二进制传输、读写文件的结构描述(为了保持文件的结构不会受到不同编译目标平台字节长度的影响)等情况下，使用更加精确的 `int32` 和 `int64` 是更好的。

:::

### 浮点型

- `float32` 类型的变量占用 4 个字节的内存，可以表示的数值范围为±1.401298464324817e-45 到±3.4028234663852886e+38，精度约为 7 个十进制位。

- `float64` 类型的变量占用 8 个字节的内存， 可以表示的数值范围为±4.9406564584124654e-324 到±1.7976931348623157e+308，精度约为 15 个十进制位。

Go 语言中的浮点数默认为 `float64` 类型，如果需要使用 `float32` 类型，需要显式声明。

```go
package main

import (
	"fmt"
	"math"
)

func showFloat() {
	var num1 float32 = math.MaxFloat32
	var num2 float64 = math.MaxFloat64
	fmt.Printf("num1的类型是%T,num1是%g\n", num1, num1)
	fmt.Printf("num2的类型是%T,num1是%g\n", num2, num2)
}

func main() {
	showFloat()
}
//num1的类型是float32,num1是3.4028235e+38
//num2的类型是float64,num1是1.7976931348623157e+308
```

### 字符

字符串中的每一个元素叫作“字符”，定义字符时使用单引号。Go 语言的字符有两种。

- `byte`类型，占用1个字节，表示 UTF-8 字符串的单个字节的值，表示的是 ASCII 码表中的一个字符，uint8 的别名类型
- `rune`类型，占用4个字节，表示单个 unicode 字符，int32 的别名类型

```go
package main

import "fmt"

func showChar() {
     var x byte = 65
     var y uint8 = 65
     fmt.Printf("x = %c\n", x)   // x = A
     fmt.Printf("y = %c\n", y)   // y = A
}

func sizeOfChar() {
    var x byte = 65
    fmt.Printf("x = %c\n", x)
    fmt.Printf("x 占用 %d 个字节\n", unsafe.Sizeof(x))

    var y rune = 'A'
    fmt.Printf("y = %c\n", y)
    fmt.Printf("y 占用 %d 个字节\n", unsafe.Sizeof(y))
}

func main() {
    showChar();
    sizeOfChar();
}
```

### 字符串

字符串在Go语言中是基本数据类型。

```go
var study string  	 		// 定义名为str的字符串类型变量
study = "《123》"		// 将变量赋值
study2 := "《789》"		// 以自动推断方式初始化
```

定义多行字符串的方法如下。

- 双引号书写字符串被称为字符串字面量（string literal），这种字面量不能跨行。
- 多行字符串需要使用反引号“`”，多用于内嵌源码和内嵌数据。
- 在反引号中的所有代码不会被编译器识别，而只是作为字符串的一部分。

```go
package main
import "fmt"

func main() {
  var s1 string
	s1 = `
    		study := 'Go语言'
    		fmt.Println(study)
			`
	fmt.Println(s1)
}
```

### 布尔

```go
func showBool(){
	a := true
	b := false
	fmt.Println("a=", a)
	fmt.Println("b=", b)
	fmt.Println("true && false = ", a && b)
	fmt.Println("true || false = ", a || b)
}

func main() {
    showBool()
}
```

### 复数

| 类 型      | 字 节 数 | 说 明                                               |
| ---------- | -------- | --------------------------------------------------- |
| complex64  | 8        | 64 位的复数型，由 float32 类型的实部和虚部联合表示  |
| complex128 | 16       | 128 位的复数型，由 float64 类型的实部和虚部联合表示 |

```go
func showComplex() {
	// 内置的 complex 函数用于构建复数
	var x complex64 = complex(1, 2)
	var y complex128 = complex(3, 4)
	var z complex128 = complex(5, 6)
	fmt.Println("x = ", x)
	fmt.Println("y = ", y)
	fmt.Println("z = ", z)

	// 内建的 real 和 imag 函数分别返回复数的实部和虚部
	fmt.Println("real(x) = ", real(x))
	fmt.Println("imag(x) = ", imag(x))
	fmt.Println("y * z = ", y*z)
}

func main() {
   showComplex()
}
```

:::tip

同样可以用自然方式表示复数

```go
x := 1 + 2i
y := 3 + 4i
z := 5 + 6i
```

:::

### fmt格式化输出

| **格式** | **含义**                                                     |
| -------- | ------------------------------------------------------------ |
| %%       | 一个%字面量                                                  |
| %b       | 一个二进制整数值(基数为 2)，或者是一个(高级的)用科学计数法表示的指数为 2 的浮点数 |
| %c       | 字符型。可以把输入的数字按照 ASCII 码相应转换为对应的字符    |
| %d       | 一个十进制数值(基数为 10)                                    |
| %f       | 以标准记数法表示的浮点数或者复数值                           |
| %o       | 一个以八进制表示的数字(基数为 8)                             |
| %p       | 以十六进制(基数为 16)表示的一个值的地址，前缀为 0x,字母使用小写的 a-f 表示 |
| %q       | 使用 Go 语法以及必须时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字 |
| %s       | 字符串。输出字符串中的字符直至字符串中的空字符（字符串以’\0‘结尾，这个’\0’即空字符） |
| %t       | 以 true 或者 false 输出的布尔值                              |
| %T       | 使用 Go 语法输出的值的类型                                   |
| %x       | 以十六进制表示的整型值(基数为十六)，数字 a-f 使用小写表示    |
| %X       | 以十六进制表示的整型值(基数为十六)，数字 A-F 使用小写表示    |

## 容器类型

### 数组

Go 中的数组是值类型而不是引用类型。当数组赋值给一个新的变量时，该变量会得到一个原始数组的一个副本。如果对新变量进行更改，不会影响原始数组。

```go
func arrByValue() {
	arr := [...]string{"123", "456", "789"}
	copy := arr
	copy[0] = "Golang"
	fmt.Println(arr)
	fmt.Println(copy)
}
```

#### 声明

`var variable_name [SIZE]variable_type`

#### 初始化

- `var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}`
- `balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}`

如果数组长度不确定，可以使用 **...** 代替数组的长度，编译器会根据元素个数自行推断数组的长度：

```go
var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
或
balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
```

如果设置了数组的长度，我们还可以通过指定下标来初始化元素：

```go
//  将索引为 1 和 3 的元素初始化
balance := [5]float32{1:2.0,3:7.0}
```

初始化数组中 **{}** 中的元素个数不能大于 **[]** 中的数字。

如果忽略 **[]** 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：

```go
 balance[4] = 50.0
```

#### 访问

数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。例如：

```go
var salary float32 = balance[9]
```

#### 数组长度

`len(arr)`

#### 数组遍历

使用`for range循环`

```go
func showArr() {
	arr := [...]string{"123", "456", "789"}
	for index, value := range arr {
		fmt.Printf("arr[%d]=%s\n", index, value)
	}

	for _, value := range arr {
		fmt.Printf("value=%s\n", value)
	}
}
```

### 切片Slice

Go 语言切片是对数组的抽象。

Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片("动态数组")，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。

#### 定义切片

```go
var identifier []type
```

切片不需要说明长度。

或使用 **make()** 函数来创建切片:

```go
var slice1 []type = make([]type, len)

也可以简写为

slice1 := make([]type, len)
```

也可以指定容量，其中 **capacity** 为可选参数。

```go
make([]T, length, capacity)
```

这里 len 是数组的长度并且也是切片的初始长度。

#### 切片初始化

直接初始化切片，**[]** 表示是切片类型，**{1,2,3}** 初始化值依次是 **1,2,3**，其 **cap=len=3**。

```go
s :=[] int {1,2,3 } 
```

初始化切片 **s**，是数组 arr 的引用。

```go
s := arr[:] 
```

将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片。

```go
s := arr[startIndex:endIndex] 
```

默认 endIndex 时将表示一直到arr的最后一个元素。

```go
s := arr[startIndex:] 
```

默认 startIndex 时将表示从 arr 的第一个元素开始。

```go
s := arr[:endIndex] 
```

通过切片 s 初始化切片 s1。

```go
s1 := s[startIndex:endIndex] 
```

通过内置函数 **make()** 初始化切片**s**，**[]int** 标识为其元素类型为 int 的切片。

```go
s :=make([]int,len,cap) 
```

> `make([]T, length, capacity)` 用于创建一个指定类型 `T`、长度为 `length`、容量为 `capacity` 的切片。其中，`length` 表示切片的实际长度，而 `capacity` 则表示切片底层数组的容量。
>
> 切片的容量可以理解为底层数组能够容纳的元素数量。当切片的容量不足以容纳新添加的元素时，Go 会自动将底层数组扩展一倍，并将原有的元素复制到新的数组中。因此，在预先分配足够容量的情况下，可以避免频繁的内存分配和数据复制操作，提高代码的性能。
>
> 需要注意的是，`capacity` 参数不能小于 `length` 参数。如果 `capacity` 小于 `length`，则会抛出一个运行时异常。

- 由于 slice 是引用类型，所以你不对它进行赋值的话，它的默认值是 `nil`

```go
var numList []int
fmt.Println(numList == nil) // true
```

- 切片之间不能比较，因此我们不能使用 `==` 操作符来判断两个 slice 是否含有全部相等元素。特别注意，如果你需要测试一个 slice 是否是空的，使用 `len(s) == 0` 来判断，而不应该用 `s == nil` 来判断。

#### 切片的长度和容量

一个 slice 由三个部分构成：**指针** 、 **长度** 和 **容量** 。指针指向第一个 slice 元素对应的底层数组元素的地址，要注意的是 slice 的第一个元素并不一定就是数组的第一个元素。长度对应 slice 中元素的数目；长度不能超过容量，容量一般是从 slice 的开始位置到底层数据的结尾位置。简单的讲，容量就是从创建切片索引开始的底层数组中的元素个数，而长度是切片中的元素个数。

内置的 `len` 和 `cap` 函数分别返回 slice 的长度和容量。

```go
s := make([]string, 3, 5)
fmt.Println(len(s)) // 3
fmt.Println(cap(s)) // 5
```

#### 切片元素修改

切片自己不拥有任何数据。它只是底层数组的一种表示。对切片所做的任何修改都会反映在底层数组中。

```go
func modifySlice() {
	var arr = [...]string{"123", "456", "789"}
	s := arr[:] //[0:len(arr)]
	fmt.Println(arr) 
	fmt.Println(s)

	s[0] = "Go语言"
	fmt.Println(arr) 
	fmt.Println(s) 
}
```

这里的 `arr[:]` 没有填入起始值和结束值，默认就是 `0` 和 `len(arr)` 。

#### 追加切片元素

使用 `append` 可以将新元素追加到切片上。`append` 函数的定义是 `func append(slice []Type, elems ...Type) []Type` 。其中 `elems ...Type` 在函数定义中表示该函数接受参数 `elems` 的个数是可变的。这些类型的函数被称为可变参数。

```go
func appendSliceData() {
	s := []string{"123"}
	fmt.Println(s)
	fmt.Println(cap(s))

	s = append(s, "567")
	fmt.Println(s)
	fmt.Println(cap(s))

	s = append(s, "789", "0")
	fmt.Println(s)
	fmt.Println(cap(s))

	s = append(s, []string{"1", "2"}...)
	fmt.Println(s)
	fmt.Println(cap(s))
}
```

当新的元素被添加到切片时，如果容量不足，会创建一个新的数组。现有数组的元素被复制到这个新数组中，并返回新的引用。现在新切片的容量是旧切片的两倍。

#### 多维切片

类似于数组，切片也可以有多个维度。

```go
func mSlice() {
	numList := [][]string{
		{"1", "123"},
		{"2", "456"},
		{"3", "789"},
	}
	fmt.Println(numList)
}
```

### Map

在 Go 语言中，map 是散列表(哈希表)的引用。它是一个拥有键值对元素的**无序集合**，在这个集合中，键是唯一的，可以通过键来获取、更新或移除操作。无论这个散列表有多大，这些操作基本上是通过常量时间完成的。所有可比较的类型，如 `整型` ，`字符串` 等，都可以作为 `key` 。

#### 创建Map

使用 `make` 函数传入键和值的类型，可以创建 map 。具体语法为 `make(map[KeyType]ValueType)` 。

```go
// 创建一个键类型为 string 值类型为 int 名为 scores 的 map
scores := make(map[string]int)
steps := make(map[string]string)
```

字面量创建：

```go
var steps2 map[string]string = map[string]string{
		"第一步": "123",
		"第二步": "456",
		"第三步": "789",
}
fmt.Println(steps2)
```

```go
steps3 := map[string]string{
		"第一步": "123",
		"第二步": "456",
		"第三步": "789",
}
fmt.Println(steps3)
```

#### Map操作

- 添加元素

  ```GO
  // 可以使用 `map[key] = value` 向 map 添加元素。
  steps3["第四步"] = "总监"
  ```

- 更新元素

  ```GO
  // 若 key 已存在，使用 map[key] = value 可以直接更新对应 key 的 value 值。
  steps3["第四步"] = "CTO"
  ```

- 获取元素

  ```GO
  // 直接使用 map[key] 即可获取对应 key 的 value 值,如果 key不存在,会返回其 value 类型的零值。
  fmt.Println(steps3["第四步"] )
  ```

- 删除元素

  ```GO
  //使用 delete(map, key)可以删除 map 中的对应 key 键值对,如果 key 不存在,delete 函数会静默处理，不会报错。
  delete(steps3, "第四步")
  ```

- 判断 key 是否存在

  ```GO
  // 如果我们想知道 map 中的某个 key 是否存在，可以使用下面的语法：value, ok := map[key]
  v3, ok := steps3["第三步"]
  fmt.Println(ok)
  fmt.Println(v3)
  
  v4, ok := steps3["第四步"]
  fmt.Println(ok)
  fmt.Println(v4)
  ```

  这个语句说明 `map` 的下标读取可以返回两个值，第一个值为当前 `key` 的 `value` 值，第二个值表示对应的 `key` 是否存在，若存在 `ok` 为 `true` ，若不存在，则 `ok` 为 `false` 。

- 遍历 map

  ```GO
  // 遍历 map 中所有的元素需要用 for range 循环。
  for key, value := range steps3 {
      fmt.Printf("key: %s, value: %s\n", key, value)
  }
  ```

- 获取 map 长度

  ```GO
  // 使用 len 函数可以获取 map 长度
  func createMap() {
    	//...
       fmt.Println(len(steps3))    // 4
  }
  ```

#### map是引用类型

当 `map` 被赋值为一个新变量的时候，它们指向同一个内部数据结构。因此，改变其中一个变量，就会影响到另一变量。

```GO
func mapByReference() {
		steps4 := map[string]string{
		"第一步": "123",
		"第二步": "456",
		"第三步": "789",
	}
	fmt.Println("steps4: ", steps4)
	// steps4:  map[第一步:123 第三步:789 第二步:456]
	newSteps4 := steps4
	newSteps4["第一步"] = "123-222"
	newSteps4["第二步"] = "456-222"
	newSteps4["第三步"] = "789-222"
	fmt.Println("steps4: ", steps4)
  // steps4:  map[第一步:123-222 第三步:789-222 第二步:456-222]
	fmt.Println("newSteps4: ", newSteps4)
  // newSteps4:  map[第一步:123-222 第三步:789-222 第二步:456-222]
}
```

当 `map` 作为函数参数传递时也会发生同样的情况。